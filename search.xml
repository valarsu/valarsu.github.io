<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
    
    <entry>
      <title><![CDATA[vue踩坑日记]]></title>
      <url>http://valar.me/2017/05/22/vue-experience/</url>
      <content type="html"><![CDATA[<blockquote>
<p>实践是检验真理的唯一标准，很多新东西不是你觉得学会了就真的会了，或多或少会踩点坑，坑踩的多了，你就习惯了😂。<br>– 我随便说的</p>
</blockquote>
<p>最近接触了一些vue相关的项目<code>（vue-cli+webpack）</code>，根据踩过的坑，稍微总结了一下，上干货。</p>
<ul>
<li><p>代码规格要求很严</p>
<ul>
<li>最开始的时候，发现vue对代码格式的要求近乎变态，一个空格有错误都会导致整个项目编译中断。后来搞清楚了，是因为<code>vue-cli</code>脚手架生成的配置文件自动增加了<code>eslint</code>插件，这个插件的作用就是为了保证代码统一风格，必要的时候也回避免一些低级错误。如果是改别人的代码，而且情况比较紧急，一条一条改很麻烦，那么可以暂时关闭<code>eslint</code>。方法是将<code>webpack.base.conf.js</code>内的rules 里面的<code>eslint-loader</code>部分去掉。<br><img src="https://leanote.com/api/file/getImage?fileId=5922b31cab64410d7e0002ea" alt="具体图示"></li>
</ul>
</li>
</ul>
<p>注：建议等有空闲时间的时候再把他改回来，养成一个良好的代码风格很重要的😀。</p>
<ul>
<li><p>路径引用中的<code>@</code>符</p>
<ul>
<li><code>vue-cli</code>在生成项目的时候，会默认把静态文件的 <code>src</code>目录用<code>@</code>符号命名。那在项目引用的时候可以用<code>@</code>代替 <code>src</code> 文件夹，这样看起来比较直观。实际上这个<code>@</code>符号也可以换成其他字符串，这个就看个人喜好了。</li>
</ul>
</li>
<li><p>cnpm 换回 npm</p>
<ul>
<li>vue 项目中，是用 cnpm 装的依赖可能会报错导致项目编译中断，具体的报错信息已经找不到了，解决方法是将 cnpm 换回 npm，如果觉得慢，就把 npm 的源换成淘宝的源。因为 cnpm 和 npm 生成的<code>node_modules</code>文件夹内的依赖插件的 结构不同，所以感觉 cnpm 会看起来稍微有点那么不正经。建议弃 cnpm，一直用 npm。</li>
</ul>
</li>
<li><p>首页白屏时间过长</p>
<ul>
<li>执行 <code>npm run build</code>打包项目之后，会生成 <code>index.html</code>、<code>app.css</code>、<code>app.js</code>、<code>manifest.js</code>和<code>vendor.js</code>。这里重点提一下<code>vendor.js</code>，这个文件是项目所依赖的所有公共库打包成的文件，如果依赖的公共库过多或者体积过大，都会造成<code>vendor.js</code>体积过大，而这个文件的大小对项目的性能有直接的关系，特别是移动端，理论上最好不要超过200kb，太大了又浪费流量又浪费等待时间。这里有一种方法，启用 gzip 压缩就可以极大的缩小文件体积，但是<code>vue-cli</code>生成的项目虽然有配置 gzip，但是需要条件达成才可以，代码在<code>webpack.prod.conf.js</code>里面。我比较笨，没有找到触发这个的条件。所以就用了一种简单粗暴的方法，将gzip 相关的内容放到<code>plugins</code>的配置里面，让他强制执行，这样就可以一直启用 gzip 压缩，使依赖文件体积变小，这个很大程度上能解决首页白屏时间过长的问题。<br><img src="https://leanote.com/api/file/getImage?fileId=5922c214ab6441107b0004b7" alt="具体图示"></li>
</ul>
</li>
<li>父子组件之间简单的信息传递<ul>
<li>父子组件间信息传递一直是这类组件化的框架的比较麻烦的问题，通常来说，小项目直接用 <code>props</code> 属性传递，大项目就要用到<code>vuex</code>来控制。我在实际运用的过程中发现父组件给子组件之间传递信息可以用<code>props</code>，但是多多少少也有点麻烦。我这里用了一种投机取巧的方法，利用storage 来存储需要传递的参数，因为 storage 是全局的，这样做也会起到需要用到这个属性的组件同步的作用。</li>
</ul>
</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 总结 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于跨域]]></title>
      <url>http://valar.me/2017/04/20/about-cross-domain/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文作为笔记整理，请看原文：<a href="http://mp.weixin.qq.com/s/G37_ZBIj_WkSpCyTuTpg3g" target="_blank" rel="external">那些年，那些跨域问题</a></p>
</blockquote>
<h1 id="跨域背景"><a href="#跨域背景" class="headerlink" title="跨域背景"></a>跨域背景</h1><p>早期为了防止CSRF（跨域请求伪造）的攻击，浏览器引入了同源策略来提高安全性。</p>
<p>同源策略：同域名（domain或ip）、同端口、同协议才能互相获取资源，而不能访问其他域的资源。所以虽然提高了安全性，但是在获取资源方面就要麻烦一点。</p>
<h2 id="JS跨域"><a href="#JS跨域" class="headerlink" title="JS跨域"></a>JS跨域</h2><h3 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h3><p>同源策略不会阻止动态脚本插入到文档中去，所以产生了JSONP。</p>
<ul>
<li>原生方法：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">script = <span class="built_in">document</span>.createElement(<span class="string">'script'</span>);</div><div class="line">script.type = <span class="string">'text/javascript'</span>;</div><div class="line">script.src = <span class="string">'http://www.b.com/getdata?callback=demo'</span>;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">demo</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data.msg);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<ul>
<li>jQuery方法</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//callback后面的?会由jQuery自动生成方法名</span></div><div class="line">$.getJSON(<span class="string">'http://www.b.com/getdata?callback=?'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(data.msg);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">$.ajax(&#123;</div><div class="line">  <span class="attr">url</span>: <span class="string">'http://www.b.com/getdata?callback=?'</span>, <span class="comment">//不指定回调名，可省略callback参数，会由jQuery自动生成</span></div><div class="line">  dataType: <span class="string">'jsonp'</span>,</div><div class="line">  <span class="attr">jsonpCallback</span>: <span class="string">'demo'</span>, <span class="comment">//可省略</span></div><div class="line">  success: <span class="function"><span class="keyword">function</span>(<span class="params">data</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(data.msg);</div><div class="line">  &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="document-domain"><a href="#document-domain" class="headerlink" title="document.domain"></a>document.domain</h3><p>如果想获取子域名中的数据，只要基础域名相同，就可以通过修改document.domain为基础域名的方式来进行通信，但是协议和端口必须相同。</p>
<p>document.a.com中通过设置</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</div></pre></td></tr></table></figure>
<p>www.a.com 中：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">document</span>.domain = <span class="string">'a.com'</span>;</div><div class="line"><span class="keyword">var</span> iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</div><div class="line">iframe.src = <span class="string">'http://document.a.com'</span>;</div><div class="line">iframe.style.display = <span class="string">'none'</span>;</div><div class="line"><span class="built_in">document</span>.body.appendChild(iframe);</div><div class="line"></div><div class="line">iframe.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> targetDocument = iframe.contentDocument || iframe.contentWindow.document;</div><div class="line">  <span class="comment">//可以操作targetDocument</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="window-postMessage"><a href="#window-postMessage" class="headerlink" title="window.postMessage"></a>window.postMessage</h3><p>postMessage是H5新增在window上的方法，目的是为了解决父子页面上的通信问题，也就是跨文档消息。可以实现较为安全可信的跨域通信。</p>
<p>postMessage有两个参数</p>
<ul>
<li>message：要传递的对象，只支持字符串信息，因此如果需要发送对象，可以使用JSON.stringify和JSON.parse做处理。</li>
<li>targetOrigin：目标域，需要注意的是协议，端口和主机名必须与要发送的消息和窗口一致。如果不想限定域，可以使用通配符“*”，但是从安全上考虑，不建议。</li>
</ul>
<p>首先，先创建一个demo的html文件，我们这里采用的是iframe的跨域，当然也可以跨窗口。</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">p</span>&gt;</span></div><div class="line">  <span class="tag">&lt;<span class="name">button</span> <span class="attr">id</span>=<span class="string">"sendMsg"</span>&gt;</span>sendMsg<span class="tag">&lt;/<span class="name">button</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">p</span>&gt;</span></div><div class="line"><span class="tag">&lt;<span class="name">iframe</span> <span class="attr">id</span>=<span class="string">"receiveMsg"</span> <span class="attr">src</span>=<span class="string">"http://b.html"</span>&gt;</span></div><div class="line"><span class="tag">&lt;/<span class="name">iframe</span>&gt;</span></div></pre></td></tr></table></figure>
<p>然后，在sendMsg的按钮上绑定点击事件，触发postMessage方法来发送信息给iframe:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> receiveMsg = <span class="built_in">document</span>.getElementById(<span class="string">'receiveMsg'</span>).contentWindow; <span class="comment">//获取在iframe中显示的窗口</span></div><div class="line">  <span class="keyword">var</span> sendBtn = <span class="built_in">document</span>.getElementById(<span class="string">'sendMsg'</span>);</div><div class="line"></div><div class="line">  sendBtn.addEventListener(<span class="string">'click'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    e.preventDefault();</div><div class="line">    receiveMsg.postMessage(<span class="string">'Hello world'</span>, <span class="string">'http://b.html'</span>);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>接着，你需要在iframe的绑定的页面源中监听message事件就能正常获取消息了。其中，MessageEvent对象有三个重要属性：data用于获取数据，source用于获取发送消息的窗口对象，origin用于获取发送消息的源。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">window</span>.onload = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> messageBox = <span class="built_in">document</span>.getElementById(<span class="string">'messageBox'</span>);</div><div class="line"></div><div class="line">  <span class="built_in">window</span>.addEventListener(<span class="string">'message'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</div><div class="line">    <span class="comment">//do something</span></div><div class="line">    <span class="comment">//考虑安全性，需要判断一下信息来源</span></div><div class="line">    <span class="keyword">if</span>(e.origin !== <span class="string">'http://xxxx'</span>) <span class="keyword">return</span>;</div><div class="line">    messageBox.innerHTML = e.data;</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h2 id="CORS"><a href="#CORS" class="headerlink" title="CORS"></a>CORS</h2><p>CORS（跨域资源共享）是W3C出的一个标准，兼容IE8+。核心思想是通过一系列新增的HTTP头信息来实现服务器和客户端之间的通信。</p>
<p>在CORS标准中，会根据是否触发CORS预请求来区分简单请求和非简单请求。</p>
<h3 id="简单请求"><a href="#简单请求" class="headerlink" title="简单请求"></a>简单请求</h3><p>条件：</p>
<ul>
<li>请求方法只允许GET、HEAD、POST</li>
<li>请求头字段要求严格，一般不超过以下几个<ul>
<li>Accept</li>
<li>Accept-Language</li>
<li>Content-Language</li>
<li>Content-Type</li>
</ul>
</li>
<li>发起POST请求时，只允许<code>Content-Type</code>为<code>application/x-www-form-urlencoded,multipart/form-data,text/plain</code>。</li>
</ul>
<p>浏览器发送一个带有Orgin字段的HTTP请求头，用来表明请求来源。服务器的Access-Control-Allow-Origin响应头表明该服务器允许哪些源的访问，一旦不匹配，浏览器就会拒绝资源的访问。大部分情况，大家都喜欢将Access-Control-Allow-Origin设置为*,即任意外域都能访问该资源。但是，还是推荐做好访问控制，以保证安全性。</p>
<h3 id="非简单请求"><a href="#非简单请求" class="headerlink" title="非简单请求"></a>非简单请求</h3><p>非简单请求在正是发送请求数据之前，浏览器会先发送一个带有“OPTIONS”方法的亲求来确保该请求对于目标站点来说事安全的。</p>
<p>浏览器会在预检请求中，多发送两个字段<code>Access-Control-Request-Method</code>和<code>Access-Control-Request-Headers</code>,前者用于告知服务器实际请求所用的方法，后者用于告知服务器实际请求所携带的自定义请求首部字段。然后，服务器将根据请求头的信息来判断是否允许该请求。</p>
<p>针对非简单请求，服务器端可以设置几个相关字段:</p>
<ul>
<li>Access-Control-Allow-Methods, 用来限制允许的方法名，</li>
<li>Access-Control-Allow-Header,用来限制允许的自定义字段名</li>
<li>Access-Control-Allow-Credentials，用来表明服务器是否允许credentials标志为true的场景。</li>
<li>Access-Control-Max-Age,用来表明预检请求响应的有效时间</li>
<li>Access-Control-Expose-Headers，用来指定服务器端允许的首部字段集合</li>
</ul>
<p>另外，如果是在具体的实践过程中，调试OPTIONS请求可以使用</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">curl -X OPTIONS http://xxx.com</div></pre></td></tr></table></figure>
<p>来进行查看相应头信息。也可以通过<code>chrome://net-internals/#events</code>来获取更加详细的网络请求信息。</p>
<h3 id="优化CORS"><a href="#优化CORS" class="headerlink" title="优化CORS"></a>优化CORS</h3><p>如果每次请求都要发送于请求，就会导致接口返回有延迟，时间被加长。</p>
<ul>
<li>请求缓存：可以在服务器端使用<code>Access-Control-Max-Age</code>来缓存预请求结果，提高性能。</li>
<li>针对GET请求：没必要使用<code>Content-Type</code>，尽可能的保持GET请求是简单请求，从安全上考虑，所有API调用应该尽可能使用https协议，这样可以将一些授权认证信息（比如token）直接放在url中去，不必放在头部，减少Header上所携带的字段。</li>
<li>针对POST请求：尽量使用FormData这种原生的格式：</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sendQuery</span>(<span class="params">url, postData</span>) </span>&#123;</div><div class="line">  <span class="keyword">let</span> formData = <span class="keyword">new</span> FormData();</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> key <span class="keyword">in</span> postData) &#123;</div><div class="line">    formData.append(key, postData.key);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> fetch(url, &#123;</div><div class="line">    <span class="attr">body</span>: formData,</div><div class="line">    <span class="attr">headers</span>: &#123;</div><div class="line">      <span class="string">'Accept'</span>: <span class="string">'*/*'</span></div><div class="line">    &#125;,</div><div class="line">    <span class="attr">method</span>: <span class="string">'POST'</span></div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line">sendQuery(<span class="string">'http://www.xxx.com'</span>, &#123;<span class="attr">msg</span>: <span class="string">'hello'</span>&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">response</span>) </span>&#123;</div><div class="line">  <span class="comment">//do something with response</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h2 id="服务器端跨域"><a href="#服务器端跨域" class="headerlink" title="服务器端跨域"></a>服务器端跨域</h2><h3 id="反向代理"><a href="#反向代理" class="headerlink" title="反向代理"></a>反向代理</h3><p>反向代理服务器是代理服务器的一种。客户端直接发送请求给代理服务器，然后代理服务器会根据客户端的请求，从真实的资源服务器中获取资源返回给客户端。所以反向代理就隐藏了真实的服务器。我们可以利用这个特性将其他域名的资源映射称自己的域名来规避开跨域问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> http = <span class="built_in">require</span>(<span class="string">'http'</span>);</div><div class="line"></div><div class="line"><span class="keyword">const</span> server = http.createServer(<span class="function">(<span class="params">req, res</span>) =&gt;</span> &#123;</div><div class="line">    <span class="keyword">const</span> proxy_req = http.request(&#123;</div><div class="line">        <span class="attr">port</span>: <span class="number">8080</span>,</div><div class="line">        <span class="attr">host</span>: req.headers[<span class="string">'host'</span>],</div><div class="line">        <span class="attr">method</span>: req.method,</div><div class="line">        <span class="attr">paht</span>: req.url,</div><div class="line">        <span class="attr">headers</span>: req.headers</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    proxy_req.on(<span class="string">'response'</span>, proxy_res =&gt; &#123;</div><div class="line">        proxy_res.on(<span class="string">'data'</span>, data =&gt; &#123;</div><div class="line">            res.write(data, <span class="string">'binary'</span>);</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        proxy_res.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">            res.end();</div><div class="line">        &#125;);</div><div class="line"></div><div class="line">        res.writeHead(proxy_res.statusCode, proxy_res.headers);</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    req.on(<span class="string">'end'</span>, () =&gt; &#123;</div><div class="line">        proxy_req.end();</div><div class="line">    &#125;);</div><div class="line"></div><div class="line">    req.on(<span class="string">'data'</span>, data =&gt; &#123;</div><div class="line">        proxy_req.write(data, <span class="string">'binary'</span>);</div><div class="line">    &#125;);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">server.listen(<span class="number">80</span>);</div></pre></td></tr></table></figure>
<p>以上代码会将请求80端口的资源映射到8080端口上去。原理就是在监听到客户端请求后，启动一个代理服务器，然后获取代理服务器返回的结果，直接返回给客户端。</p>
<p>express:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">const</span> express = <span class="built_in">require</span>(<span class="string">'express'</span>);</div><div class="line"><span class="keyword">const</span> request = <span class="built_in">require</span>(<span class="string">'request'</span>);</div><div class="line"><span class="keyword">const</span> app = express();</div><div class="line"></div><div class="line"><span class="keyword">const</span> proxyServer = <span class="string">'loaclhost:8080'</span>;</div><div class="line"></div><div class="line">app.use(<span class="string">'/'</span>, (req, res) =&gt; &#123;</div><div class="line">    <span class="keyword">const</span> url = proxyServer + req.url;</div><div class="line">    req.pipe(request(url)).pipe(res);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">app.listen(process.env.PORT || <span class="number">80</span>);</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[深入理解JSON]]></title>
      <url>http://valar.me/2017/04/19/about-JSON/</url>
      <content type="html"><![CDATA[<blockquote>
<p>本文作为笔记整理，请看原文：<a href="http://mp.weixin.qq.com/s/CQKFfecqy3_EgW0jLfEMIQ" target="_blank" rel="external">深入理解JSON</a></p>
</blockquote>
<h1 id="JSON是一种格式，基于文本，优于轻量，用于交换数据"><a href="#JSON是一种格式，基于文本，优于轻量，用于交换数据" class="headerlink" title="JSON是一种格式，基于文本，优于轻量，用于交换数据"></a>JSON是一种格式，基于文本，优于轻量，用于交换数据</h1><h2 id="基于文本的数据格式"><a href="#基于文本的数据格式" class="headerlink" title="基于文本的数据格式"></a>基于文本的数据格式</h2><p>基于文本的数据格式，相对于基于二进制的数据</p>
<h2 id="轻量级的数据格式"><a href="#轻量级的数据格式" class="headerlink" title="轻量级的数据格式"></a>轻量级的数据格式</h2><p>JSON之前普遍用xml，相对于mxl，json更轻量。因为xml的标签部分就占用了很多空间，而json占用带宽更小，所以在大量数据交互的时候优势很大</p>
<h2 id="用于数据交换的数据格式"><a href="#用于数据交换的数据格式" class="headerlink" title="用于数据交换的数据格式"></a>用于数据交换的数据格式</h2><p>除了轻量化，JSON易于阅读、编写和及其解析，对人和及其都非常友好。因为基于文本，所以独立于语言。</p>
<a id="more"></a>
<h1 id="JSON和JS对象的区别"><a href="#JSON和JS对象的区别" class="headerlink" title="JSON和JS对象的区别"></a>JSON和JS对象的区别</h1><h1 id="两者之间的关系"><a href="#两者之间的关系" class="headerlink" title="两者之间的关系"></a>两者之间的关系</h1><p>两者就像斑马线和斑马，斑马线基于斑马的条纹来呈现和命名，但是斑马是活的，斑马线非生物。</p>
<p>JSON只是一种格式，可以说是一种标准，JS对象是实例，存在于内存中。只不过JSON是基于JS对象产生的。与JS对象语法相似，但是JSON更严格</p>
<p>JSON可以传输，JS对象却没办法传输。</p>
<h2 id="JSON语法要求"><a href="#JSON语法要求" class="headerlink" title="JSON语法要求"></a>JSON语法要求</h2><ul>
<li>键名：必须是双引号</li>
<li>属性值：只能是熟知、字符串（双引号）、布尔值、null、数组，不能是函数、NaN、Infinity、-Infinity、undefined</li>
<li>最后一个属性后面不能有逗号</li>
<li>前导0不能用，小数点后必须有数字</li>
</ul>
<h1 id="JSON相关函数"><a href="#JSON相关函数" class="headerlink" title="JSON相关函数"></a>JSON相关函数</h1><h2 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h2><p>将JS对象转化成JSON格式的字符串</p>
<p><code>JSON.stringify(value[, replacer [, space]])</code></p>
<ul>
<li>一个参数：正常使用，参数为JSON格式的对象或者数组，返回一个JSON字符串</li>
<li>第二个参数：<ul>
<li>函数：序列化过程中每个属性都会被这个函数转化和处理，且必须每一项都有返回</li>
<li>数组：只有包含在这个数组中的属性才会被序列化到最终的JSON字符串中</li>
<li>null，那作用上和空着一样，如果不想设置第二个参数，只想设置第三个参数的时候看，就可以将第二个参数设为null</li>
</ul>
</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> friend2 = &#123;</div><div class="line">    <span class="string">"firstName"</span>: <span class="string">"Good"</span>,</div><div class="line">    <span class="string">"lastName"</span>: <span class="string">"Man"</span>,</div><div class="line">    <span class="string">"phone"</span>:<span class="string">"1234567"</span>,</div><div class="line">    <span class="string">"age"</span>:<span class="number">18</span></div><div class="line">&#125;</div><div class="line"><span class="comment">// 函数</span></div><div class="line"><span class="keyword">var</span> friend2After1 = <span class="built_in">JSON</span>.stringify(friend2, <span class="function"><span class="keyword">function</span> (<span class="params">key, value</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (key === <span class="string">'phone'</span>)&#123;</div><div class="line">        <span class="keyword">return</span> <span class="string">"(000)"</span> + value;</div><div class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> value === <span class="string">"number"</span>) &#123;</div><div class="line">        <span class="keyword">return</span> value + <span class="number">10</span>;</div><div class="line">    &#125; <span class="keyword">else</span> &#123;</div><div class="line">        <span class="keyword">return</span> value;</div><div class="line">    &#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// 数组</span></div><div class="line"><span class="keyword">var</span> friend2After2 = <span class="built_in">JSON</span>.stringify(friend2, [<span class="string">'lastName'</span>, <span class="string">'age'</span>]);</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(friend2After1); <span class="comment">//&#123;"firstName":"Good","lastName":"Man","phone":"(000)1234567","age":28&#125;</span></div><div class="line"><span class="built_in">console</span>.log(friend2After2); <span class="comment">//&#123;"lastName":"Man","age":18&#125;</span></div></pre></td></tr></table></figure>
<ul>
<li><p>第三个参数：美化输出（不建议）</p>
<ul>
<li>是1-10的某个数字，代表用几个空白字符</li>
<li>是字符串的话，就用该字符串代替空格，最多取这个字符串的前10个字符</li>
<li>没有提供该参数 等于 设置成null 等于 设置一个小于 1 的数</li>
</ul>
</li>
<li><p>注意事项：</p>
<ul>
<li>键名会自动变成双引号，字符串是单引号的也会自动变成双引号</li>
<li>最后一个属性后面如果有逗号，会被自动去掉</li>
<li>非数组对象在最终字符串中属性顺序不一定和原来一致</li>
<li>布尔值、数字、字符串的包装对象在序列化过程中会自动转换成对应的原始值，new String(“xxxx”)会变成”xxxx”，new Number(2017)会变成2017等等</li>
<li>undefined、任意函数、以及symbol值出现在非数组对象的属性之中，在序列化过程中会被忽略，出现在数组中时，会被转成null</li>
<li>NaN、Infinity、-Infinity，不论在数组中还是在非数组的对象中，都会转化成null</li>
<li>所有symbol为属性键的属性都会被完全忽略掉，即使replacer参数中强制指定包含了他们</li>
<li>不可枚举的属性会被忽略</li>
</ul>
</li>
</ul>
<h2 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h2><p>将JSON格式的字符串转化成符合JSON格式的字符串</p>
<p><code>JSON.parse(text[, reviver])</code></p>
<ul>
<li>第一个参数，JSON字符串，注意如果不合标准，函数会报错</li>
<li>第二个参数必须是一个函数，这个函数作用在属性已经被解析但是还没反悔钱，将属性处理后再返回</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> friend3 = &#123;</div><div class="line">    <span class="string">"firstName"</span>: <span class="string">"Good"</span>,</div><div class="line">    <span class="string">"lastName"</span>: <span class="string">"Man"</span>,</div><div class="line">    <span class="string">"phone"</span>:&#123;<span class="string">"home"</span>:<span class="string">"1234567"</span>,<span class="string">"work"</span>:[<span class="string">"7654321"</span>,<span class="string">"999000"</span>]&#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> friend3After1 = <span class="built_in">JSON</span>.stringify(friend3);</div><div class="line"></div><div class="line"><span class="built_in">JSON</span>.parse(friend3After1, <span class="function"><span class="keyword">function</span> (<span class="params">k, v</span>) </span>&#123;</div><div class="line"><span class="built_in">console</span>.log(k);</div><div class="line"><span class="built_in">console</span>.log(v);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">"----"</span>);</div><div class="line"></div><div class="line"><span class="comment">// firstName</span></div><div class="line"><span class="comment">// Good</span></div><div class="line"><span class="comment">// ----</span></div><div class="line"><span class="comment">// lastName</span></div><div class="line"><span class="comment">// Man</span></div><div class="line"><span class="comment">// ----</span></div><div class="line"><span class="comment">// home</span></div><div class="line"><span class="comment">// 1234567</span></div><div class="line"><span class="comment">// ----</span></div><div class="line"><span class="comment">// 0</span></div><div class="line"><span class="comment">// 7654321</span></div><div class="line"><span class="comment">// ----</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 999000</span></div><div class="line"><span class="comment">// ----</span></div><div class="line"><span class="comment">// work</span></div><div class="line"><span class="comment">// []</span></div><div class="line"><span class="comment">// ----</span></div><div class="line"><span class="comment">// phone</span></div><div class="line"><span class="comment">// Object</span></div><div class="line"><span class="comment">// ----</span></div><div class="line"><span class="comment">//</span></div><div class="line"><span class="comment">// Object</span></div><div class="line"><span class="comment">// ----</span></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[关于apply、call和bind()]]></title>
      <url>http://valar.me/2017/03/01/apply-bind-call/</url>
      <content type="html"><![CDATA[<blockquote>
<p>call、apply、bind()最近查了不少资料进行总结，主要参考链接： <a href="http://mp.weixin.qq.com/s/BYbCgTMt7nvChPddWor0Tw" target="_blank" rel="external">原文链接</a></p>
</blockquote>
<h1 id="call和apply"><a href="#call和apply" class="headerlink" title="call和apply"></a>call和apply</h1><h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>js中，<code>call</code>和<code>apply</code>都是为了改变某个函数运行时的上下文而存在的，就是为了改变函数体内部的<code>this</code>指向。</p>
<p>函数存在<code>定义时上下文</code>、<code>运行时上下文</code>和<code>上下文是可以改变的</code>这样的概念。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">fruits</span>(<span class="params"></span>)</span>&#123;&#125;</div><div class="line"></div><div class="line">fruits.prototype = &#123;</div><div class="line">    <span class="attr">color</span>: <span class="string">'red'</span>,</div><div class="line">    <span class="attr">say</span>: <span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">"My color is "</span> + <span class="keyword">this</span>.color + a * b);</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> apple = <span class="keyword">new</span> fruits();</div><div class="line">apple.say(<span class="number">3</span>, <span class="number">4</span>);<span class="comment">//My color is red12;</span></div></pre></td></tr></table></figure>
<p>如果我们有一个对象，不想对他重新定义<code>say</code>方法，那么可以通过<code>call</code>或者<code>apply</code>来使用apple的<code>say</code>方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> banana = &#123;</div><div class="line">    <span class="attr">color</span>: <span class="string">'yellow'</span></div><div class="line">&#125;;</div><div class="line">apple.say.call(banana, <span class="number">4</span>, <span class="number">5</span>);<span class="comment">//My color is yellow 20</span></div><div class="line">apple.say.apply(banana, [<span class="number">5</span>, <span class="number">6</span>]);<span class="comment">//My color is yellow 20</span></div></pre></td></tr></table></figure>
<p>所以可以看出，<code>call</code>和<code>apply</code>是为了动态改变this而出现的，当一个object没有某个方法时，但是其他的对象有，那么可以借助<code>call</code>或者<code>apply</code>,用其他方法来操作。</p>
<h2 id="call和apply的区别"><a href="#call和apply的区别" class="headerlink" title="call和apply的区别"></a><code>call</code>和<code>apply</code>的区别</h2><p>作用完全一样，但是接受参数的方式不一样<code>var func = function (arg1, arg2){}</code>可以通过以下方式调用：</p>
<ul>
<li><code>func.call(this, arg1, arg2)</code></li>
<li><code>func.apply(this, [arg1, arg2])</code></li>
</ul>
<p>其中<code>this</code>是指你想指定的上下文，可以是任意一个js对象，<code>call</code>需要把参数按顺序传递进去，而<code>apply</code>要把参数放在数组里。<br>因为某些函数的参数数量是不定的，所以一般在知道数组数量时用call，不确定时，用apply将参数push进数组传递。也可以通过arguments这个数组来遍历所有参数。</p>
<h1 id="bind"><a href="#bind" class="headerlink" title="bind()"></a>bind()</h1><h2 id="简介-1"><a href="#简介-1" class="headerlink" title="简介"></a>简介</h2><p><code>bind()</code> 方法与 <code>apply</code> 和 <code>call</code> 很相似，也是可以改变函数体内 <code>this</code> 的指向。</p>
<p>平时我们会使用 <code>_this</code> , <code>that</code> , <code>self</code> 等保存 <code>this</code> ，这样我们可以在改变了上下文之后继续引用到它。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    <span class="attr">bar</span> : <span class="number">1</span>,</div><div class="line">    <span class="attr">eventBind</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="keyword">var</span> _this = <span class="keyword">this</span>;</div><div class="line">        $(<span class="string">'.someClass'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">            <span class="comment">/* Act on the event */</span></div><div class="line">            <span class="built_in">console</span>.log(_this.bar); <span class="comment">//1</span></div><div class="line">        &#125;);</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>由于 Javascript 特有的机制，上下文环境在 <code>eventBind:function(){ }</code> 过渡到 <code>$(&#39;.someClass&#39;).on(&#39;click&#39;,function(event) { })</code> 发生了改变，保存<code>this</code>方法很常见，使用<code>bind()</code>可以更好的解决这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    <span class="attr">bar</span> : <span class="number">1</span>,</div><div class="line">    <span class="attr">eventBind</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        $(<span class="string">'.someClass'</span>).on(<span class="string">'click'</span>,<span class="function"><span class="keyword">function</span>(<span class="params">event</span>) </span>&#123;</div><div class="line">            <span class="comment">/* Act on the event */</span></div><div class="line">            <span class="built_in">console</span>.log(<span class="keyword">this</span>.bar); <span class="comment">//1</span></div><div class="line">        &#125;.bind(<span class="keyword">this</span>));</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>这里面，<code>bind()</code>创建了一个函数，当这个click事件在被调用的时候，他的<code>this</code>关键词会被设置成被传入的值，因此，我们传入想要的上下文环境的<code>this</code>到<code>bind()</code>函数中，然后被调用的时候，<code>this</code>的环境就会变了。</p>
<h1 id="apply、call、bind-的比较"><a href="#apply、call、bind-的比较" class="headerlink" title="apply、call、bind()的比较"></a>apply、call、bind()的比较</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;</div><div class="line">    <span class="attr">x</span>: <span class="number">81</span></div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = &#123;</div><div class="line">    <span class="attr">getX</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">        <span class="keyword">return</span> <span class="keyword">this</span>.x;</div><div class="line">    &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(foo.getX.bind(obj)()); <span class="comment">//81</span></div><div class="line"><span class="built_in">console</span>.log(foo.getX.call(obj)); <span class="comment">//81</span></div><div class="line"><span class="built_in">console</span>.log(foo.getX.apply(obj)); <span class="comment">//81</span></div></pre></td></tr></table></figure>
<p>输出都是81，但是注意<code>bind()</code>方法，后面加了括号。</p>
<p>所以如果想让改变<code>this</code>指向之后不立即执行，可以用<code>bind()</code>方法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><ul>
<li>三种方法都是用来改变<code>this</code>指向的</li>
<li>第一个参数都是<code>this</code>要指向的对象</li>
<li>都可以利用后续参数传递</li>
<li><code>bind</code>返回对应函数，不立即执行，<code>apply/call</code>是立即执行</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[蜜汁this]]></title>
      <url>http://valar.me/2017/02/23/about-this/</url>
      <content type="html"><![CDATA[<blockquote>
<p>在JavaScript（以下称js）中，this是指向当前函数中正在执行的上下文环境。js有四种不同的函数调用类型：</p>
</blockquote>
<ol>
<li>函数调用：alert(‘hello world’);</li>
<li>方法调用：console.log(‘hello world’);</li>
<li>构造函数调用：new RegExp(‘\d’);</li>
<li>间接调用：alert.call(undefined,’hello world’);</li>
</ol>
<blockquote>
<p>理解this的关键在于理解不同的调用类型以及他是如何影响上下文环境的。</p>
</blockquote>
<h1 id="函数调用中的this"><a href="#函数调用中的this" class="headerlink" title="函数调用中的this"></a><span style="color: rgb(51, 153, 102);" data-mce-style="color: #339966;">函数调用中的this</span></h1><h2 id="非严格模式下："><a href="#非严格模式下：" class="headerlink" title="非严格模式下："></a><span style="color: rgb(0, 0, 0);" data-mce-style="color: #000000;">非严格模式下：</span></h2><blockquote>
<p>this在函数调用中是全局对象，全局对象取决于当前执行环境，在浏览器中全局对象就是window。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);<span class="comment">//true</span></div><div class="line">	<span class="keyword">this</span>.myNumber = <span class="number">14</span>;<span class="comment">//在全局对象中添加myNumber属性</span></div><div class="line">	<span class="built_in">console</span>.log(a + b);</div><div class="line">&#125;;</div><div class="line">sum(<span class="number">15</span>, <span class="number">16</span>);<span class="comment">//31</span></div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.myNumber);<span class="comment">//14</span></div></pre></td></tr></table></figure>
<blockquote>
<p><span id="mce_3_start" style="overflow:hidden;line-height:0px" data-mce-type="bookmark" data-mce-style="overflow:hidden;line-height:0px">﻿</span>this在任何函数作用域以外调用时（最外层作用域：全局执行上下文环境），也会涉及到全局对象。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>); <span class="comment">//true</span></div><div class="line"><span class="keyword">this</span>.myString = <span class="string">'Hello World!'</span>;</div><div class="line"><span class="built_in">console</span>.log(<span class="built_in">window</span>.myString);<span class="comment">//Hello World! ﻿​</span></div></pre></td></tr></table></figure>
<h2 id="严格模式下："><a href="#严格模式下：" class="headerlink" title="严格模式下："></a>严格模式下：</h2><p>严格模式由ES5.1标准引进，用来限制js的一些异常处理，提供更好的安全性和更强的错误检查机制。</p>
<blockquote>
<p>this在严格模式下的函数调用中是undefined</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">multiply</span>(<span class="params">a ,b</span>) </span>&#123;</div><div class="line"><span class="meta">	'use strict'</span>; <span class="comment">//开启严格模式</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="literal">undefined</span>); <span class="comment">//true</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//undefined</span></div><div class="line">	<span class="keyword">return</span> a * b;</div><div class="line">&#125;;</div><div class="line"><span class="built_in">console</span>.log(multiply(<span class="number">2</span>, <span class="number">6</span>));<span class="comment">//12</span></div></pre></td></tr></table></figure>
<blockquote>
<p>严格模式不仅在当前作用域起到作用，他还会影响内部作用域，即内部声明的一切内部函数的作用域。（内部函数继承严格模式）</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">execute</span>(<span class="params"></span>) </span>&#123;</div><div class="line"><span class="meta">	'use strict'</span>;</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">concat</span>(<span class="params">str1, str2</span>) </span>&#123;</div><div class="line">		<span class="comment">//内部函数也是严格模式</span></div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="literal">undefined</span>); <span class="comment">// true</span></div><div class="line">		<span class="built_in">console</span>.log(str1 + str2);</div><div class="line">	&#125;</div><div class="line">	<span class="comment">//在严格模式下调用 concat()</span></div><div class="line">	<span class="comment">//this在concat()下是undefined</span></div><div class="line">	concat(<span class="string">'Hello '</span>, <span class="string">'World!'</span>);<span class="comment">//Hello World</span></div><div class="line">&#125;;</div><div class="line">execute();</div></pre></td></tr></table></figure>
<blockquote>
<p>严格和非严格混合使用时，this会有不同的表现</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">nonStrictSum</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line">	<span class="comment">//非严格模式</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="built_in">window</span>);<span class="comment">//true</span></div><div class="line">	<span class="built_in">console</span>.log(a + b);</div><div class="line">	<span class="function"><span class="keyword">function</span> <span class="title">strictSum</span>(<span class="params">a, b</span>) </span>&#123;</div><div class="line"><span class="meta">		'use strict'</span>;</div><div class="line">		<span class="comment">//严格模式</span></div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === <span class="literal">undefined</span>); <span class="comment">//true</span></div><div class="line">		<span class="built_in">console</span>(a + b);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">nonStrictSum(<span class="number">5</span>, <span class="number">6</span>);<span class="comment">//11</span></div><div class="line">StrictSum(<span class="number">5</span>, <span class="number">7</span>);<span class="comment">//12</span></div></pre></td></tr></table></figure>
<h2 id="函数调用中的陷阱："><a href="#函数调用中的陷阱：" class="headerlink" title="函数调用中的陷阱："></a>函数调用中的陷阱：</h2><blockquote>
<p>误区：内部函数中的this等同于他的外部函数中的this</p>
<p>正解：内部函数的上下文环境取决于调用环境，而不是外部函数的上下文环境</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = &#123;</div><div class="line">	<span class="attr">numberA</span>: <span class="number">5</span>,</div><div class="line">	<span class="attr">numberB</span>: <span class="number">10</span>,</div><div class="line">	<span class="attr">sum</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="comment">// 'use strict';</span></div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === numbers); <span class="comment">//true</span></div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="comment">//严格模式下this是window/undefined</span></div><div class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span> === numbers);<span class="comment">//false</span></div><div class="line">			<span class="keyword">return</span> <span class="keyword">this</span>.numberA + <span class="keyword">this</span>.numberB;</div><div class="line">		&#125;</div><div class="line">		<span class="built_in">console</span>.log(calculate());</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.numberA + <span class="keyword">this</span>.numberB);<span class="comment">//15</span></div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">numbers.sum();<span class="comment">//严格模式下报错,非严格模式下结果是NaN</span></div></pre></td></tr></table></figure>
<blockquote>
<p>numbers.sum() 是对象内的一个方法调用，因此 sum 的上下文是 numbers 对象，而 calculate 函数定义在 sum 函数内，所以会误以为在 calculate 内 this 也指向的是 numbers。</p>
<p>然而 calculate() 在函数调用（而不是作为方法调用）时，此时的 this 指向的是全局对象 window 或者在严格模式下指向 undefined ，即使外部函数 sum 拥有 numbers对象作上下文环境，它也没有办法影响到内部的 this。</p>
<p>解决方法是使calculate函数被调用时的上下文同sum调用时一样，所以用.call()方法改变calculate改变sum的上下文环境。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> numbers = &#123;</div><div class="line">	<span class="attr">numberA</span>: <span class="number">5</span>,</div><div class="line">	<span class="attr">numberB</span>: <span class="number">10</span>,</div><div class="line">	<span class="attr">sum</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === numbers); <span class="comment">//true</span></div><div class="line">		<span class="function"><span class="keyword">function</span> <span class="title">calculate</span>(<span class="params"></span>) </span>&#123;</div><div class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span> === numbers);<span class="comment">//true</span></div><div class="line">			<span class="built_in">console</span>.log(<span class="keyword">this</span>.numberA + <span class="keyword">this</span>.numberB);</div><div class="line">		&#125;</div><div class="line">		<span class="comment">//使用.call()方法修改上下文环境</span></div><div class="line">		<span class="keyword">return</span> calculate.call(<span class="keyword">this</span>);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line">numbers.sum();<span class="comment">//15</span></div></pre></td></tr></table></figure>
<h1 id="方法调用中的this"><a href="#方法调用中的this" class="headerlink" title="方法调用中的this"></a><span style="color: #339966;" data-mce-style="color: #339966;">方法调用中的this</span></h1><p><span style="color: #339966;" data-mce-style="color: #339966;"><img src="https://leanote.com/api/file/getImage?fileId=58783e11ab644175f4001b73" alt=""></span></p>
<blockquote>
<p>this在方法调用中代表的是调用该方法的对象本身</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> calc = &#123;</div><div class="line">	<span class="attr">num</span>: <span class="number">0</span>,</div><div class="line">	<span class="attr">increment</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === calc);<span class="comment">//true</span></div><div class="line">		<span class="keyword">this</span>.num += <span class="number">1</span>;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.num);</div><div class="line">	&#125;</div><div class="line">&#125;;</div><div class="line"><span class="comment">//方法调用，this指向calc</span></div><div class="line">calc.increment();<span class="comment">//1</span></div><div class="line">calc.increment();<span class="comment">//2</span></div></pre></td></tr></table></figure>
<blockquote>
<p>一个js对象继承方法来自于它自身的属性，当一个被继承方法在对象中调用时，上下文执行环境同样是对象本身。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> myDog = <span class="built_in">Object</span>.create(&#123;</div><div class="line">	<span class="attr">sayName</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === myDog);<span class="comment">//true</span></div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;);</div><div class="line"><span class="comment">// myDog.name = 'Hehe';</span></div><div class="line"><span class="comment">//方法调用，this指向myDog</span></div><div class="line">myDog.sayName();<span class="comment">//Hehe</span></div></pre></td></tr></table></figure>
<blockquote>
<p>在ES5的class语法中，方法调用指的是实例本身</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Planet</span> </span>&#123;</div><div class="line">	<span class="keyword">constructor</span>(name) &#123;</div><div class="line">		<span class="keyword">this</span>.name = name;</div><div class="line">	&#125;</div><div class="line">	getName() &#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === earth);</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> earth = <span class="keyword">new</span> Planet(<span class="string">'Earth'</span>);</div><div class="line">earth.getName();<span class="comment">//Earth</span></div></pre></td></tr></table></figure>
<h2 id="方法调用中的陷阱："><a href="#方法调用中的陷阱：" class="headerlink" title="方法调用中的陷阱："></a>方法调用中的陷阱：</h2><blockquote>
<p>误区：一个对象中的方法可能会被提取抽离成一个变量。当时用这个变量调用方法时，开发者可能会误认为this指向的还是定义该方法时的对象</p>
<p>正解：如果方法调用不依靠对象，那么就是一个函数调用，即 this 指向全局对象 object 或者在严格模式下为undefined。创建函数绑定可以修复上下文，使该方法被正确对象调用。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Animal</span>(<span class="params">type, legs</span>) </span>&#123;</div><div class="line">	<span class="keyword">this</span>.type = type;</div><div class="line">	<span class="keyword">this</span>.legs = legs;</div><div class="line">	<span class="keyword">this</span>.logInfo = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span> === myCat);<span class="comment">//false</span></div><div class="line">		<span class="built_in">console</span>.log(<span class="keyword">this</span>.type + <span class="string">' has '</span> + <span class="keyword">this</span>.legs + <span class="string">' legs'</span>);<span class="comment">//undefined has undefined legs</span></div><div class="line">	&#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> myCat = <span class="keyword">new</span> Animal(<span class="string">'Cat'</span>, <span class="number">4</span>);</div><div class="line">setTimeout(myCat.logInfo, <span class="number">1000</span>);</div></pre></td></tr></table></figure>
<blockquote>
<p>开发者可能认为在 setTimeout 下调用 myCat.logInfo() 会打印出 myCat 对象的信息。但实际上这个方法被分离了出来作为了参数传入函数内 setTimeout(myCat.logInfo)，然后 1s 后会发生函数调用。当logInfo 被作为函数调用时，this 指向全局对象 window 或者在严格模式下为 undefined，因此对象信息没有正确地被打印。</p>
<p>可以用bind()方法改变绑定myCat对象，改变上下文</p>
</blockquote>
<p><img src="https://leanote.com/api/file/getImage?fileId=58783e11ab644175f4001b75" alt=""></p>
<blockquote>
<p>此时，myCat.logInfo.bind(myCat) 返回的新函数调用里的 this 指向了 myCat。</p>
</blockquote>
<h1 id="构造函数调用中的this"><a href="#构造函数调用中的this" class="headerlink" title="构造函数调用中的this"></a><span style="color: #339966;" data-mce-style="color: #339966;">构造函数调用中的this</span></h1><blockquote>
<p>this在构造函数调用时指向新创建的对象</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Foo</span>(<span class="params"></span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span> <span class="keyword">instanceof</span> Foo); <span class="comment">//true</span></div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span>); <span class="comment">//Foo&#123;&#125;</span></div><div class="line">	<span class="keyword">this</span>.property = <span class="string">'Default Value'</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//构造函数调用</span></div><div class="line"><span class="keyword">var</span> fooInstance = <span class="keyword">new</span> Foo();</div><div class="line"><span class="built_in">console</span>.log(fooInstance.property);<span class="comment">//Default Value</span></div></pre></td></tr></table></figure>
<blockquote>
<p>new Foo() 建立构造器调用，它的上下文环境为 fooInstance，在 Foo 对象中初始化了 this.property 这个属性并赋予初始值。</p>
</blockquote>
<h2 id="构造函数中的陷阱："><a href="#构造函数中的陷阱：" class="headerlink" title="构造函数中的陷阱："></a>构造函数中的陷阱：</h2><blockquote>
<p>一些js函数创建实例，不仅仅可以使用构造器的形式调用也可以利用函数调用。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> reg1 = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'\\w+'</span>);</div><div class="line"><span class="keyword">var</span> reg2 = <span class="built_in">RegExp</span>(<span class="string">'\\w+'</span>);</div><div class="line"></div><div class="line">reg1 iinstanceof <span class="built_in">RegExp</span>;<span class="comment">//true</span></div><div class="line">reg2 iinstanceof <span class="built_in">RegExp</span>;<span class="comment">//treu</span></div><div class="line">reg1.source === reg2.source;<span class="comment">//true</span></div></pre></td></tr></table></figure>
<p>当执行 new RegExp()和RegExp()时，js创建了两个相等的普通表达式对象。</p>
<p>但是使用函数调用创建对象会产生潜在的问题（包括工厂模式），当时去了new关键字，一些构造器会取消初始化对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Vehicle</span>(<span class="params">type, wheelsCount</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>);<span class="comment">//window</span></div><div class="line">	<span class="keyword">this</span>.type = type;</div><div class="line">	<span class="keyword">this</span>.wheelsCount = wheelsCount;</div><div class="line">	<span class="keyword">return</span> <span class="keyword">this</span>;</div><div class="line">&#125;</div><div class="line"><span class="comment">//函数调用</span></div><div class="line"><span class="keyword">var</span> car = Vehicle(<span class="string">'Car'</span>, <span class="number">5</span>);</div><div class="line"><span class="built_in">console</span>.log(car.type);</div><div class="line"><span class="built_in">console</span>.log(car.wheelsCount); <span class="comment">//5</span></div><div class="line"><span class="built_in">console</span>.log(car === <span class="built_in">window</span>);<span class="comment">//true</span></div></pre></td></tr></table></figure>
<blockquote>
<p>Vehicle 是一个在对象上设置了 type 和 wheelsCount 属性的函数。</p>
<p>当执行了 Vehicle(‘Car’, 4) 时，会返回对象 car，它拥有正确的属性值：car.type 指向Car，car.wheelsCount 指向 4，开发者会误以为这样创建初始化对象没有什么问题。<br>然而，当前执行的是函数调用，因此 this 指向的是 window 对象，所以它设置的属性其实是挂在 window对象上的，这样是完全错误的，它并没有创建一个新对象。</p>
</blockquote>
<h1 id="间接调用中的this"><a href="#间接调用中的this" class="headerlink" title="间接调用中的this"></a><span style="color: #339966;" data-mce-style="color: #339966;">间接调用中的this</span></h1><blockquote>
<p>this是间接调用中.call()或者.apply()的第一个参数</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> rabbit = &#123;<span class="attr">name</span>: <span class="string">'White Rabbit'</span>&#125;;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">concatName</span>(<span class="params">string,string1</span>) </span>&#123;</div><div class="line">	<span class="built_in">console</span>.log(<span class="keyword">this</span> === rabbit);<span class="comment">//true</span></div><div class="line">	<span class="built_in">console</span>.log(string + string1 + <span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="comment">//间接调用</span></div><div class="line">concatName.call(rabbit, <span class="string">'Hello '</span>, <span class="string">'Bye '</span>);<span class="comment">//Hello Bye White Rabbit</span></div><div class="line">concatName.apply(rabbit, [<span class="string">'你好 '</span>, <span class="string">'再见 '</span>]);<span class="comment">//你好 再见 White Rabbit</span></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[js获取URL中的参数]]></title>
      <url>http://valar.me/2017/02/23/url-params/</url>
      <content type="html"><![CDATA[<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">//获取url中的参数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParam</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    <span class="keyword">var</span> reg = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">"(^|&amp;)"</span> + name + <span class="string">"=([^&amp;]*)(&amp;|$)"</span>); <span class="comment">//构造一个含有目标参数的正则表达式对象</span></div><div class="line">    <span class="keyword">var</span> r = <span class="built_in">window</span>.location.search.substr(<span class="number">1</span>).match(reg);  <span class="comment">//匹配目标参数</span></div><div class="line">    <span class="keyword">if</span> (r != <span class="literal">null</span>) <span class="keyword">return</span> <span class="built_in">unescape</span>(r[<span class="number">2</span>]); <span class="keyword">return</span> <span class="literal">null</span>; <span class="comment">//返回参数值</span></div><div class="line">&#125;</div><div class="line"><span class="comment">//举个栗子</span></div><div class="line"><span class="keyword">var</span> url = http:<span class="comment">//192.168.2.14:8084/wap/building/7/appointment.htm?id=7</span></div><div class="line"><span class="built_in">console</span>.log(getUrlParam(id))<span class="comment">//7</span></div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[css设置文字溢出变省略号]]></title>
      <url>http://valar.me/2017/02/23/text-overflow/</url>
      <content type="html"><![CDATA[<h3 id="单行省略"><a href="#单行省略" class="headerlink" title="单行省略"></a>单行省略</h3><figure class="highlight css"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="selector-class">.title</span>&#123;</div><div class="line">    <span class="attribute">overflow</span>: hidden;</div><div class="line">    <span class="attribute">white-space</span>: nowrap;</div><div class="line">    <span class="attribute">text-overflow</span>: ellipsis;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="多行省略"><a href="#多行省略" class="headerlink" title="多行省略"></a>多行省略</h3><figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//webkit</div><div class="line">p &#123;</div><div class="line">    overflow : hidden;</div><div class="line">    text-overflow: ellipsis;</div><div class="line">    display: -webkit-box;</div><div class="line">    -webkit-line-clamp: 2;</div><div class="line">    -webkit-box-orient: vertical;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">//-o-ellipsis-lastline</div><div class="line">p &#123;</div><div class="line">    overflow: hidden;</div><div class="line">    white-space: normal;</div><div class="line">    height: 3em;</div><div class="line">    text-overflow: -o-ellipsis-lastline;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<figure class="highlight"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line">//jquery跨浏览器</div><div class="line">$(".figcaption").each(function(i)&#123;</div><div class="line">    var divH = $(this).height();</div><div class="line">    var $p = $("p", $(this)).eq(0);</div><div class="line">    while ($p.outerHeight() &gt; divH) &#123;</div><div class="line">        $p.text($p.text().replace(/(\s)*([a-zA-Z0-9]+|\W)(\.\.\.)?$/, "..."));</div><div class="line">    &#125;;</div><div class="line">&#125;);﻿​</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gulp给静态资源配置md5的踩坑历程]]></title>
      <url>http://valar.me/2017/02/22/gulp-rev/</url>
      <content type="html"><![CDATA[<blockquote>
<p>最近负责的项目缓存问题很严重，所以打算搞一下gulp给静态资源添加md5的解决方案。</p>
</blockquote>
<p>我在网上查了很多方法，最初决定用<code>gulp-rev</code>配合<code>gulp-rev-collector</code>的方法。</p>
<p>如果没有gulp基础，参考<a href="http://www.gulpjs.com.cn" target="_blank" rel="external">Gulp中文网</a></p>
<h2 id="（一）"><a href="#（一）" class="headerlink" title="（一）"></a>（一）</h2><p>下面是我的gulpfile.js文件</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="keyword">var</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>); <span class="comment">//- 编译sass文件为css；</span></div><div class="line"><span class="keyword">var</span> rev = <span class="built_in">require</span>(<span class="string">'gulp-rev'</span>); <span class="comment">//- 对文件名加MD5后缀</span></div><div class="line"><span class="keyword">var</span> revCollector = <span class="built_in">require</span>(<span class="string">'gulp-rev-collector'</span>); <span class="comment">//- 路径替换</span></div><div class="line"></div><div class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">//- 创建一个名为 sass 的 task</span></div><div class="line">    gulp.src(<span class="string">'./css/*.scss'</span>) <span class="comment">//- sass文件存放路径</span></div><div class="line">        .pipe(sass()) <span class="comment">//- 编译sass文件为css</span></div><div class="line">        .pipe(rev()) <span class="comment">//- 文件名加MD5后缀</span></div><div class="line">        .pipe(gulp.dest(<span class="string">'./css'</span>)) <span class="comment">//- 输出文件本地，因为sass编译后为css文件，所以可以输出到和sass相同的目录</span></div><div class="line">        .pipe(rev.manifest()) <span class="comment">//- 生成一个rev-manifest.json</span></div><div class="line">        .pipe(gulp.dest(<span class="string">'./rev'</span>)); <span class="comment">//- 将 rev-manifest.json 保存到 rev 目录内</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'rev'</span>, [<span class="string">'sass'</span>], <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="comment">// setTimeout(function () &#123;</span></div><div class="line">        gulp.src([<span class="string">'./rev/*.json'</span>, <span class="string">'./view/*.html'</span>])   <span class="comment">//- 读取 rev-manifest.json 文件以及需要进行css名替换的文件</span></div><div class="line">            .pipe(revCollector()) <span class="comment">//- 执行文件内css名的替换</span></div><div class="line">            .pipe(gulp.dest(<span class="string">'./'</span>)); <span class="comment">//- 替换后的文件输出的目录</span></div><div class="line">    <span class="comment">// &#125;, 100);</span></div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'sass'</span>, <span class="string">'rev'</span>]);</div></pre></td></tr></table></figure>
<p>rev-manifest.json文件:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&#123;</div><div class="line">  <span class="attr">"test.css"</span>: <span class="string">"test-53c212701b.css"</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>HTML文件编译前：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/test.css"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>HTML文件编译后：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"/test-53c212701b.css"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>但是这样我遇见了两个问题：</p>
<ul>
<li>每次编译后md5值会变，这样就会生成新的文件，不及时处理会造成文件冗余</li>
<li>替换过程执行会比编译过程快，这样造成的问题就是替换时，新的版本还没编译好，这样就会替换上一个版本的文件，这样永远慢半拍肯定是不可行的</li>
</ul>
<p>第一个问题就是蛋疼的问题，个人水平还不具备造轮子的能力，所以只能手动处理冗余文件，那这样肯定不可取了，所以我决定换一个方式。</p>
<h2 id="（二）"><a href="#（二）" class="headerlink" title="（二）"></a>（二）</h2><p>第二种方式是不用上述的两个关键插件<code>gulp-rev</code>和<code>gulp-rev-collector</code>，换用<code>gulp-rev-append-all</code>，这个插件的特点不改编译好的文件名，而是改成<code>test.css?v=53c212701b</code>的方式，以参数的形式，这样就不会添加新文件，不会造成文件冗余。而且是直接利用正则表达式搜寻<code>src=&#39;&#39;</code>和<code>href=&#39;&#39;</code>，碰见这两个，直接在后面加上参数，不需要<code>rev-manifest.json</code>作为过渡。<br>下面是我的gulp.js，这里加了监听的task，可以不考虑，直接看主体就好。<br>gulp.js<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="keyword">var</span> sass = <span class="built_in">require</span>(<span class="string">'gulp-sass'</span>);</div><div class="line"><span class="keyword">var</span> revAppend = <span class="built_in">require</span>(<span class="string">'gulp-rev-append-all'</span>);<span class="comment">//生成MD5后缀并替换到对应的文件中</span></div><div class="line"><span class="comment">// 加参数</span></div><div class="line"><span class="keyword">const</span> revBack = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  gulp.src(<span class="string">'./view/*.html'</span>)</div><div class="line">      .pipe(revAppend())</div><div class="line">      .pipe(gulp.dest(<span class="string">'./'</span>));<span class="comment">//替换后输出目录</span></div><div class="line">&#125;;</div><div class="line"><span class="comment">// 编译sass</span></div><div class="line">gulp.task(<span class="string">'sass'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">return</span> gulp.src(<span class="string">'./styles/**/*.scss'</span>)</div><div class="line">    .pipe(sass(&#123;<span class="attr">outputStyle</span>: <span class="string">'compressed'</span>&#125;).on(<span class="string">'error'</span>, sass.logError))</div><div class="line">    .pipe(gulp.dest(<span class="string">'./styles'</span>));</div><div class="line">&#125;);</div><div class="line"><span class="comment">//</span></div><div class="line">gulp.task(<span class="string">'sassRev'</span>, [<span class="string">'sass'</span>], revBack);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'watch'</span>, <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  gulp.watch(<span class="string">'./styles/**/*.scss'</span>, [<span class="string">'sassRev'</span>]);</div><div class="line">  gulp.watch(<span class="string">'./view/*.html'</span>, []);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">gulp.task(<span class="string">'default'</span>, [<span class="string">'server'</span>, <span class="string">'sassRev'</span>, <span class="string">'minifyRev'</span>,<span class="string">'watch'</span>]);</div></pre></td></tr></table></figure></p>
<p>HTML文件编译前：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./test.css"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>HTML文件编译后：</p>
<figure class="highlight html"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">"stylesheet"</span> <span class="attr">href</span>=<span class="string">"./test.css=53c212701b"</span>/&gt;</span></div></pre></td></tr></table></figure>
<p>但是还是遇见了问题，这个方法只支持相对路径，而不支持绝对路径。但是项目里面大多数引用都是绝对路径，考虑成本过大，而且时间有限，所以这种方法还是放弃。</p>
<h2 id="（三）"><a href="#（三）" class="headerlink" title="（三）"></a>（三）</h2><p>继续查资料，发现第一种方法有种改进方式，别人已经早了轮子，只要替换node_modules中的几个文件，就可以实现<code>test-53c212701b.css-&gt;test.css=53c212701b</code>，这样<code>（一）</code>中的第一个问题就解决了，gulpfile参照<code>（一）</code>。<br>参考链接：<a href="http://blog.csdn.net/u010486124/article/details/52078466" target="_blank" rel="external">Gulp——文件压缩和文件指纹</a><br>替换文件的下载链接：<a href="http://download.csdn.net/download/u010486124/9591085" target="_blank" rel="external">文件替换</a></p>
<p>其实还有<code>（一）</code>中的第二个问题，明明是等到前一个任务结束才开始执行第二个任务的</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line">[15:25:54] Starting &apos;sass&apos;...</div><div class="line">[15:25:54] Finished &apos;sass&apos; after 15 ms</div><div class="line">[15:25:54] Starting &apos;rev&apos;...</div><div class="line">[15:25:54] Finished &apos;rev&apos; after 4.56 ms</div><div class="line">[15:25:54] Starting &apos;default&apos;...</div><div class="line">[15:25:54] Finished &apos;default&apos; after 30 μs</div></pre></td></tr></table></figure>
<p>结果却是<code>rev</code>先执行完，有点匪夷所思，想不出个所以然来。试过添加定时器，可以生效，但毕竟不是个完美的解决方案。但是因为这个文件指向永远是同一个文件，不涉及到替换文件，所以添加md5的目的已经达到了。等下次有时间再搞这个问题，还要研究一下替换文件具体改了那些东西。</p>
]]></content>
      
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[gulp构建时，安装jshint报错的解决方法]]></title>
      <url>http://valar.me/2017/02/22/jshint/</url>
      <content type="html"><![CDATA[<h1 id="Error-Cannot-find-module-‘jshint-src-cli’"><a href="#Error-Cannot-find-module-‘jshint-src-cli’" class="headerlink" title="Error: Cannot find module ‘jshint/src/cli’"></a>Error: Cannot find module ‘jshint/src/cli’</h1><p>问题描述：构建gulp时，按照正常流程安装gulp-jshint<br>gulpfile.js:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> gulp = <span class="built_in">require</span>(<span class="string">'gulp'</span>);</div><div class="line"><span class="keyword">var</span> uglify = <span class="built_in">require</span>(<span class="string">'gulp-uglify'</span>);<span class="comment">//压缩js</span></div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install --save-dev jshint gulp-jshint</div></pre></td></tr></table></figure>
<p>然后运行gulp，会报错</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">module.js:442</div><div class="line">    throw err;</div><div class="line">    ^</div><div class="line"></div><div class="line">Error: Cannot find module &apos;jshint/src/cli&apos;</div><div class="line">    at Function.Module._resolveFilename (module.js:440:15)</div><div class="line">    at Function.Module._load (module.js:388:25)</div><div class="line">    at Module.require (module.js:468:17)</div><div class="line">    at require (internal/module.js:20:19)</div><div class="line">    at Object.&lt;anonymous&gt; (/Users/suhao/Documents/workspace/fanglv-tfdd/src/main/webapp/node_modules/.2.0.4@gulp-jshint/src/extract.js:1:79)</div><div class="line">    at Module._compile (module.js:541:32)</div><div class="line">    at Object.Module._extensions..js (module.js:550:10)</div><div class="line">    at Module.load (module.js:458:32)</div><div class="line">    at tryModuleLoad (module.js:417:12)</div><div class="line">    at Function.Module._load (module.js:409:3)</div></pre></td></tr></table></figure>
<p>解决方法：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install --save-dev jshint gulp-jshint</div></pre></td></tr></table></figure>
<p>那么问题来了，为什么要在 <code>gulp-jshint</code> 前面加上 <code>jshint</code> 呢？</p>
<p>原因是在执行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">cnpm install --save-dev jshint gulp-jshint</div></pre></td></tr></table></figure>
<p>会发现有一条提醒</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">peerDependencies WARNING gulp-jshint@2.0.4 requires a peer of jshint@2.x but none was installed</div></pre></td></tr></table></figure>
<p>意思是 <code>gulp-jshint2.0.4</code>版本需要以 <code>jshint@2.x</code> 版本作为依赖，但是 <code>jshint</code> 并没有被安装，而在安装 <code>gulp-jshint</code> 时并不会自动安装 <code>jshint</code> ,所以会出现本文的问题。</p>
]]></content>
      
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[HTTP笔记]]></title>
      <url>http://valar.me/2017/02/20/about-http/</url>
      <content type="html"><![CDATA[<blockquote>
<p>HTTP对我来说一直是弱项，所以最近看了很多相关资料，记录笔记如下，意在深入理解HTTP。</p>
</blockquote>
<h1 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h1><blockquote>
<p>HTTP协议是互联网上应用最为广泛的一种网络协议，也是浏览器和服务器通信时所采用的协议。在展示网页时，浏览器向服务器发起一个HTTP请求，以获取相应的网站数据，然后在客户端展示相应的内容。</p>
<p>与HTTP协议紧密相关的还有HTTPS协议，它通过SSL和HTTP协议构建可进行加密传输、身份认证的网络协议，能防止数据在传输过程中被挟持或篡改，可以看作是HTTP协议的安全版。</p>
<p>HTTP是Web开发中必须掌握的技术，除了协议本身外，缓存机制、表单的method方法，跨域、网络安全等，都是在页面开发过程中涉及的网络相关的技术点。</p>
</blockquote>
<a id="more"></a>
<h1 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h1><blockquote>
<p>TCP/IP协议族是网络通信需要的各种协议的统称。如从电缆的规格到IP地址的选当方法、寻找异地用户的方法、双方建立通信的顺序、Web页面显示需要处理的步骤等等。</p>
</blockquote>
<h2 id="分层管理"><a href="#分层管理" class="headerlink" title="分层管理"></a>分层管理</h2><ol>
<li>应用层：决定向用户提供应用服务时通信的活动。比如FTP（文件传输协议）和DNS（域名系统）服务就是其中的两类应用。</li>
<li>传输层：对应用层提供处于网络连接中的两台计算机之间的数据传输。传输层中有两个性质不同的协议，TCP（传输控制协议）和UDP（用户数据报协议）</li>
<li>网络层（网络互联层）：处理在网络上流动的数据包（网络传输的最小数据单位）。规定了通过怎样的传输路线到达对方计算机，并把数据包传送给对方。</li>
<li>数据链路层（网络接口层）：用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（网卡）、光纤等物理可见部分。</li>
</ol>
<h2 id="TCP-IP通信传输流"><a href="#TCP-IP通信传输流" class="headerlink" title="TCP/IP通信传输流"></a>TCP/IP通信传输流</h2><blockquote>
<p>应用层（HTTP协议）发送一个请求 <code>-&gt;</code> 传输层（TCP协议）把收到的数据（HTTP请求报文）进行分割，并在各报文上打标记序号及端口号 <code>-&gt;</code> 网络层（IP协议）增加作为通信目的地的MAC地址 <code>-&gt;</code> 链路层（网络） <code>-&gt;</code> 接收端以相反的方向进行。</p>
</blockquote>
<h2 id="IP、TCP和DNS"><a href="#IP、TCP和DNS" class="headerlink" title="IP、TCP和DNS"></a>IP、TCP和DNS</h2><ul>
<li>IP：网络协议（不要把IP和IP地址搞混），位于网络层，作用是要把正确的数据包传送给对方，所以要满足各种条件，最重要的是IP地址（节点被分配到的地址）和MAC地址（网卡所属的固定地址）。网络传输时，要经过多台设备进行中转，中转过程中会用ARP协议根据IP地址解析出中专目标的MAC地址。</li>
<li>TCP：位于传输层，提供可靠的字节流服务。为了传送大数据而把数据分割成以报文段为单位的数据包进行传输，并且能确定数据最终是否能到达。<ul>
<li>三次握手：为了确保能把数据送到目的地，TCP使用flag：<code>SYN</code>和<code>ACK</code>进行三次握手。发送端先发送一个带SYN的数据包给对方，对方接收到后，会回发一个带有SYN/ACK的数据包表示接收到了，然后发送端再发送一个带ACK的数据包，代表握手结束。</li>
</ul>
</li>
<li>DNS：和HTTP一样在应用层，负责域名解析。因为计算机识别IP地址比识别域名要容易，所以用DNS来将域名解析成IP地址，以供服务器识别。也可以通过IP反查域名。</li>
</ul>
<h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><ul>
<li>URI：统一资源标识符，用字符串标识某个协议方案（HTTP、FTP、file等）标识的互联网资源</li>
<li>URL：统一资源定位符，表示资源的地点（所以URL是URI的子集）</li>
</ul>
<h3 id="URI的格式"><a href="#URI的格式" class="headerlink" title="URI的格式"></a>URI的格式</h3><p><img src="http://olh78p45s.bkt.clouddn.com/image/http/WechatIMG21.jpeg" alt="URI的格式"></p>
<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><ul>
<li>应用HTTP协议时，必定有一个客户端，一个服务器端。</li>
<li>请求必定由客户端发出，收到请求后，服务器端响应该请求并返回。</li>
<li>请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。</li>
<li>响应报文由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</li>
<li>HTTP时无状态的协议，不保存状态。类似于金鱼的七秒钟记忆v_v,一次通信请求成功之后不会记录上一次的请求内容。</li>
</ul>
<h2 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h2><ul>
<li>GET：获取资源，返回通信状态及实体</li>
<li>POST：传输实体主体</li>
<li>PUT：发送文件</li>
<li>HEAD：和GET方法一样，但是只返回通信状态</li>
<li>DELETE：删除文件，与PUT的方法相反</li>
<li>OPTIONS：用来查询针对请求URI指定的资源支持的方法，响应报文会有一个Allow字段返回方法，<code>Allow: GET, POST, HEAD, OPTIONS</code></li>
<li>TRACE：让服务器端将之前的请求通信路径返回给客户端（不常用）</li>
<li>CONNECT：要求与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。</li>
</ul>
<h2 id="建立持久连接"><a href="#建立持久连接" class="headerlink" title="建立持久连接"></a>建立持久连接</h2><p>初始版本中每进行一次HTTP通信就要断开一次TCP连接，每次都要三次握手四次挥手啥的，累死了。</p>
<p>后来出现了持久连接<code>HTTP keep-alive</code>，只要任意一端没有明确提出断开连接，就保持TCP连接状态。</p>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>初始版本中发送请求后必须等待收到响应后才能发送下一个请求，管线化就是发送请求后不需要等待响应，就可以继续发送下一个请求。相当于每次请求之间实现了多线程异步处理。</p>
<h2 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h2><p>由于HTTP是无状态的协议，那么需要记住状态的请求就需要用别的方法来实现，所以引入了cookie。</p>
<p>cookie会根据从服务器端发送的响应豹纹内的首部字段信息，通知客户端保存Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发出去。</p>
<p>服务器端发现客户端发过来的cookie后，会去检查究竟是哪一个客户端发过来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<h1 id="HTTP报文内的HTTP信息"><a href="#HTTP报文内的HTTP信息" class="headerlink" title="HTTP报文内的HTTP信息"></a>HTTP报文内的HTTP信息</h1><p>用于HTTP协议交互的信息被称为HTTP报文，客户端的HTTP报文叫做请求报文，服务器端的叫做响应报文。</p>
<p>HTTP报文大致可氛围报文首部和报文主体两块，两者由最初出现的空行（CR+LF）来划分，通常报文主体不是必须的。</p>
<ul>
<li>报文首部：服务器端或者客户端处理的请求或响应的内容及属性</li>
<li>报文主体：应被发送的数据</li>
<li>报文首部结构<ul>
<li>请求报文：请求行、请求首部字段、通用首部字段、实体首部字段、其他</li>
<li>响应报文：状态行、相应首部字段、通用首部字段、实体首部字段、其他<ul>
<li>请求行：包含用于请求的方法，请求URI和HTTP版本</li>
<li>状态航：包含表明响应结果的状态码，原因短语和HTTP版本</li>
<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部</li>
<li>其他：可能包含HTTP的RFC里未定义的首部（Cookie等）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><p>HTTP在传输数据时可以按照数据原貌直接传输，但是在处理大量访问请求时可以通过编码传输，但是编码要计算机完成，因此会消耗CPU资源</p>
<h3 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h3><ul>
<li>报文：是HTTP通信的基本单位，由8个字节流组成，通过HTTP通信传输</li>
<li>实体：作为请求或相应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成</li>
<li>HTTP报文的主体用来传输请求或响应的实体主体</li>
<li>通常报文主体等于实体主体，只有在传输中进行编码操作时实体主体的内容发生变化，才导致它和它的报文主体产生差异</li>
</ul>
<h3 id="编码种类"><a href="#编码种类" class="headerlink" title="编码种类"></a>编码种类</h3><ul>
<li>内容编码：指明应用在实体内容上的编码格式，并保持实体信息原样压缩，内容编码后的实体由客户端接收并非责编码。</li>
<li>分块传输编码：HTTP通信过程中，请求的编码实体资源没传完之前浏览器没办法显示请求页面，所以在传输大容量数据时，把数据分割成多块，能让浏览器逐步显示页面。由接收的客户端来解码。</li>
<li>多部分对象集合：发送一份报文主体可以含有多类型实体，通常是在图片或文本文件等上传时使用<ul>
<li><code>Content-Type: multipart/form-data</code>：在Web表单文件上传时使用</li>
<li><code>Content-Type: multipart/byteranges</code>：状态码206（部分内容）响应报文包含了多个范围的内容时使用</li>
</ul>
</li>
<li>使用boundary字符串来划分多部分对象集合指明的各类实体</li>
</ul>
<h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><ul>
<li>下载过程中如果遇到网络中断，就必须从头开始，为了解决这个问题，需要一种可恢复的机制，使其能从之前下载中断处回复下载，也就是我们常说的断点续传。这种指定范围发送的请求叫做范围请求</li>
<li>执行范围请求时，会用到首部字段Range来制定资源的byte范围 <code>Range: bytes=5001-10000</code> 或 <code>Range: bytes=5001-</code> <code>Range: bytes=-3000，5001-10000</code> 多种写法。</li>
<li>范围请求时，响应会反悔状态码206，响应也会在首部字段<code>Content-Type</code>标明<code>multipart/byteranges</code>后返回响应报文。</li>
<li>如果服务器无法响应范围请求，则会返回状态码200 OK和完整的实体内容</li>
</ul>
<h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><ul>
<li>内容协商是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。一般以响应资源的语言、字符集、编码方式等作为判断的基准。比如访问www.google.com，浏览器默认是英文就反回英文版页面，是中文就返回中文版页面</li>
<li>包含在请求报文的某些首部字段就是判断的基准，比如：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language</li>
<li>三种类型<ul>
<li>服务器驱动协商：服务器端根据请求的首部字段作为参考，在服务器端自动处理</li>
<li>客户端驱动协商：用户通过设置浏览器、js脚本等方式，比如切换浏览器类型、PC版页面活着手机版页面等</li>
<li>透明协商：服务器端和客户端各自进行内容协商。</li>
</ul>
</li>
</ul>
<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><h2 id="每类状态码的含义"><a href="#每类状态码的含义" class="headerlink" title="每类状态码的含义"></a>每类状态码的含义</h2><ul>
<li>1xx（临时响应）：表示临时响应并需要请求者继续执行操作</li>
<li>2xx（成功）：表示成功处理了请求</li>
<li>3xx（重定向）：表示要完成请求需要进一步操作，通常这些状态码用来重定向</li>
<li>4xx（错误）：表示请求可能出错，妨碍了服务器的处理，（客户端错误）</li>
<li>5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误，（服务器端错误）</li>
</ul>
<h2 id="14种常用状态码："><a href="#14种常用状态码：" class="headerlink" title="14种常用状态码："></a>14种常用状态码：</h2><ul>
<li>200（成功）：服务器已经成功处理了请求。通常这表示服务器提供了请求的页面</li>
<li>204（成功，但是没有资源返回）：请求已经成功处理，但是响应报文中不含实体的主体部分，也不允许返回任何实体的主体</li>
<li>206（范围请求）：客户端发起范围请求，服务器成功执行，响应报文中包含由Content-Range指定范围内的实体内容</li>
<li>301（永久性重定向）：服务器告知资源的URI已经更新，以后应使用资源现在所指的URI</li>
<li>302（临时重定向）：表示请求的资源被分配了新的URI，希望用户（本次）能使用新的URI访问</li>
<li>303（发现其他URI）：请求的资源存在另一个URI，应使用GET方法定向获取请求的资源，明确使用GET方法</li>
<li>304（未修改）：客户端发送附带条件的请求时，服务器端允许请求访问资源，但是未满足条件的情况，返回时不包含任何响应的主体部分</li>
<li>307（临时重定向）：和302有相同的含义</li>
<li>400（语法错误）：请求报文中存在语法错误，需要修改请求内容后再次发送请求</li>
<li>401（未授权）：请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li>
<li>403（禁止）：服务器拒绝请求，比如未获得资源的访问授权、访问权限出现某些问题等情况</li>
<li>404（未找到）：服务器找不到请求的资源</li>
<li>500（服务器故障）：服务器端在执行请求时发生了错误，也有可能是web应用存在bug或某些临时的故障</li>
<li>503（服务器繁忙）：服务器暂时出去超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h1 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h1><p>一台web服务器既可以搭建网站，又可以作为佟鑫路径上的中转服务器提升传输效率。</p>
<h2 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h2><p>客户端使用HTTP协议访问服务器时，使用普通域名，然后DNS服务器解析成IP地址之后访问目标网站。</p>
<p>如果一台HTTP服务器通过虚拟机功能搭建多个Web站点，那么多个域名就会解析到同一个ip地址，那么问题来了，服务器怎么区分不同的域名访问的呢？<br>因为相同ip下，虚拟主机可以寄存多个主机和域名的网站，所以请求时，必须host首部内完整指定主机名或域名的URI。</p>
<h2 id="通信数据的转发程序：代理、网关、隧道"><a href="#通信数据的转发程序：代理、网关、隧道" class="headerlink" title="通信数据的转发程序：代理、网关、隧道"></a>通信数据的转发程序：代理、网关、隧道</h2><p>以上三个是用于在HTTP通信中，介于客户端和服务器端之间的用来进行数据转发的应用程序。</p>
<ul>
<li>代理：介于客户端和服务器端之间，起过渡作用。可以将请求转发给下一个服务器，并能接收那台服务器发送的响应并回传给客户端。不改变请求URI，每次使用代理服务器转发请求或者响应时，会追加Via首部信息<code>Via: proxy1， proxy2</code>，可以多台服务器同时代理，像电路的串联一样进行来回通信。<ul>
<li>应用场景：利用缓存技术减少网络带宽的流量、组织内部针对特定网站的访问限制等  </li>
<li>缓存代理：转发响应时，缓存代理会预先将资源的缓存保存在代理服务器上。这样再次接到相同的请求时，就可以将代理服务器上缓存的资源返回</li>
<li>透明代理：转发请求或响应时，不对报文做任何加工，反之则是非透明代理</li>
</ul>
</li>
<li>网关：是转发其他服务器上的数据的服务器。<ul>
<li>和代理非常相似，但是网关可以将HTTP转换为其他协议进行通信。</li>
<li>网关可以提升通信的安全性，因为可以在客户端与网关的线路上加密。比如网关可以连接数据库，或者网购使用信用卡结算时，可以和信用卡结算系统联动。</li>
</ul>
</li>
<li>隧道：在距离超级长的客户端与服务器端之间进行中转，保持双方通信安全连接。<ul>
<li>可以按要求建立起一条连接其他服务器的线路，通过SSL进行加密，目的是确保客户端和服务器端的通信安全</li>
<li>隧道是透明的，不对请求做任何修改，直接传给其他服务器，所以客户端不用在意隧道的存在，通信双方断开连接时，隧道自动断开</li>
</ul>
</li>
</ul>
<h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><ul>
<li>缓存是指代理服务器或客户端磁盘内保存的资源副本，可以减少对源服务器的访问，节省流量和时间</li>
<li>缓存服务器是代理服务器的一种，当缓存代理转发响应时，会保存一份资源的副本</li>
<li>有效性：当源服务器上的资源更新时，如果使用不变的缓存，那么缓存就会变成旧的资源，所以每次使用缓存时，都会向源服务器确认缓存的有效性，如果失效，就会从源服务器上重新获取新的资源</li>
<li>客户端缓存：本地磁盘也可以存储缓存，如果有效，就可以直接从磁盘获取资源，不用再向服务器请求。客户端缓存也有生命周期，和缓存服务器一样，向源服务器确认缓存的有效性</li>
</ul>
<h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>HTTP协议是无状态的，为了保持用户会话状态使用了什么技术方案弥补？该技术方赞在用户禁用了cookie之后，还有什么方式实现（可不考虑安全性）？</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>我们常用的保存会话状态的方式有cookie、session、URL GET参数：</p>
<ol>
<li>cookie是保存在浏览器终端内存或者磁盘上的一小块数据，只能保存字符串类型，所有的cookie信息都会随着浏览器的请求而发送。cookie分为：会话cookie：数据保存在内存中，浏览器关闭后将被清除；持久cookie：数据保存在磁盘中。尽管几乎所有浏览器都支持cookie，但是浏览器对单域下cookie的个数和每个key的长度都有限制。</li>
<li>session是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息，客户端需要接收、记忆和回送session的会话标识号，session通常是借助客户端存储的cookie来记录会话标识。</li>
<li>GET参数是URL中的普通参数，GET方式是明文传输，其传送的数据量一般会有限制，美中浏览器支持的最大长度会略有不同。</li>
</ol>
<p>要实现保持用户状态，服务端在客户端第一次访问时会自动创建一个session来存储客户端的信息，同时生成一个唯一的key发送给客户端。</p>
<ol>
<li>客户端没有禁用cookie：服务器会在客户端cookie中写入一个key的值，用户保存用户信息，之后的每一次访问都会携带cookie给服务端，服务器可以根据这个值判断用户的唯一性</li>
<li>客户端禁用了cookie：需要将验证信息写入URL中，所有的请求也需要携带这个参数，比如说<code>www.tfdd.com?session_id=xxxxx</code>，相对于cookie来说要麻烦一点，因为页面上所有的链接和请求都必须携带该参数，否则客户端会丢失会话状态</li>
</ol>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>URL输入浏览器到页面呈现，这中间发生了什么？</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ol>
<li>URL输入到浏览器，负责域名解析的DNS服务会通过域名查找对应的IP地址（也就是获得URL对应的IP地址）；</li>
<li>利用TCP/IP协议族进行网络通信，发送数据包，建立网络连接。客户端会向服务端发送请求，服务端会响应客户端的请求。其中，客户端想浏览器发送请求，发送会经历应用层（HTTP报文）-&gt;传输层（增加TCP头部）-&gt;网络层（IP数据包，增加IP头部）-&gt;数据链路层（增加以太网头部）；服务端则相反。</li>
<li>客户端渲染，渲染引擎对html进行转换，转化成能够被DOM处理的形式，接着转换成一个DOM树，在解析HTML的过程，会发送请求把对应的内容货渠道，同时进行css的解析，构建出css样式规则应用到DOM树上，然后进行一定的布局处理，最后根据这棵渲染树在浏览器窗口进行绘制。</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[我理解的闭包]]></title>
      <url>http://valar.me/2017/02/16/closure/</url>
      <content type="html"><![CDATA[<blockquote>
<p>此篇笔记根据《你不知道的JavaScript》中闭包的部分整理而成。</p>
</blockquote>
<h1 id="启示"><a href="#启示" class="headerlink" title="启示"></a>启示</h1><p>闭包在Js中无处不在，你只需要能够识别并拥抱它。人们缺少的是根据自己的意愿来识别、拥抱和影响闭包的思维环境。</p>
<a id="more"></a>
<h1 id="实质问题"><a href="#实质问题" class="headerlink" title="实质问题"></a>实质问题</h1><blockquote>
<p>当函数可以记住并访问所在的词法作用域时，就产生了闭包，即使函数实在当前词法作用域之外执行。</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(a);</div><div class="line">  &#125;</div><div class="line">  bar();</div><div class="line">&#125;</div><div class="line">foo();<span class="comment">//2</span></div></pre></td></tr></table></figure>
<p>从纯学术的角度说，上面的代码中，bar()具有一个涵盖foo()能访问的所有作用域的<code>闭包</code>，也可以认为bar()被封闭在了foo()的作用域中，因为bar()嵌套在foo()内部。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> a = <span class="number">2</span>;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span> (<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(a);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> bar;</div><div class="line">&#125;</div><div class="line"></div><div class="line">foo()();<span class="comment">//2</span></div><div class="line"></div><div class="line"><span class="keyword">var</span> baz = foo ();</div><div class="line">baz();<span class="comment">//2</span></div></pre></td></tr></table></figure></p>
<p>正常情况下，函数执行之后，该函数的整个内部作用域都被销毁，因为引擎由垃圾回收机制来释放不再使用的内存空间。而<code>闭包</code>就是在阻止内存释放，因为bar()还在使用foo()的内部作用域，所以这个作用域能够一直存活，以供bar()在之后任何时间进行引用。<code>bar()依然有对该作用域的&#39;引用&#39;，而这个引用就是</code><strong>闭包</strong>。</p>
<blockquote>
<p>bar()在定义时的词法作用域以外的地方被baz()调用，所以闭包使得函数可以继续访问定义时的词法作用域。</p>
<p>无论使用何种方式对函数类型的值进行传递，当函数在别处被调用时都可以观察到闭包。</p>
</blockquote>
<p>我的理解：<code>闭包就是能够让隐式的作用域被当前词法作用域之外访问到的一种引用。通过词法作用域的规则，返回引用作用域的函数，这样其他地方就可以随时访问这个作用域的内容。而为了保证可以随时引用，闭包会阻止引擎的垃圾回收机制，阻止其释放内存。</code></p>
<h1 id="闭包应用场景"><a href="#闭包应用场景" class="headerlink" title="闭包应用场景"></a>闭包应用场景</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">wait</span> (<span class="params">message</span>) </span>&#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  	<span class="built_in">console</span>.log(message);</div><div class="line">  &#125;, <span class="number">1000</span>);</div><div class="line">&#125;</div><div class="line"></div><div class="line">wait(<span class="string">'Hello fucking closure!'</span>);</div></pre></td></tr></table></figure>
<p>这里<code>timer</code>具有涵盖<code>wait()</code>作用域的闭包，因此还保有对变量<code>message</code>的引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">setupBot</span>(<span class="params">name, selector</span>) </span>&#123;</div><div class="line">  $( selector ).click( <span class="function"><span class="keyword">function</span> <span class="title">activator</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log( <span class="string">"Activating: "</span> + name );</div><div class="line">  &#125; );</div><div class="line">&#125;</div><div class="line">setupBot( <span class="string">"Closure Bot 1"</span>, <span class="string">"#bot_1"</span> );</div><div class="line">setupBot( <span class="string">"Closure Bot 2"</span>, <span class="string">"#bot_2"</span> );</div></pre></td></tr></table></figure>
<p>本质上无论何时何地，如果<code>将函数当作第一级的值类型并到处传递</code>，就会看到闭包的应用。在定时器，事件监听器，Ajax等任何任务中，只要使用了<code>回调函数</code>，实际上就是在使用闭包。</p>
<h1 id="循环和闭包"><a href="#循环和闭包" class="headerlink" title="循环和闭包"></a>循环和闭包</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log( i );</div><div class="line">  &#125;, i*<span class="number">1000</span> );</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>期望依次输出1，2，3，4，5，间隔一秒。然而实际输出的却是5个6，因为<code>延迟函数的回调会在循环结束时才执行</code>，循环结束时，i已变成6，但是这个时候才开始进入循环主体，所以i一直是6。</p>
<p>那如果setTimeout外面包一层立即执行函数（IIFE），让每次循环都立即进入setTimeout呢？也不行，因为虽然每个延迟函数都会将IIFE在每次循环中创建的作用域中封闭起来，但是<code>如果作用域是空的，那么仅仅封闭是不够的，必须要有实质内容才能用</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="keyword">var</span> j = i;</div><div class="line">      setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="built_in">console</span>.log( j );</div><div class="line">      &#125;, j*<span class="number">1000</span> );</div><div class="line">  &#125;)();</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>改进一下<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">1</span>; i&lt;=<span class="number">5</span>; i++) &#123;</div><div class="line">  (<span class="function"><span class="keyword">function</span>(<span class="params">j</span>) </span>&#123;</div><div class="line">      setTimeout( <span class="function"><span class="keyword">function</span> <span class="title">timer</span>(<span class="params"></span>) </span>&#123;</div><div class="line">          <span class="built_in">console</span>.log( j );</div><div class="line">      &#125;, j*<span class="number">1000</span> );</div><div class="line">  &#125;)(i);</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>这样在迭代内使用IIFE会为每个迭代都产生一个新的作用域，使得延迟函数的回调可以将新的作用域封闭在每个迭代内部，每个迭代中都会含有一个具有正确值的变量供我们访问。</p>
<h1 id="模块"><a href="#模块" class="headerlink" title="模块"></a>模块</h1><figure class="highlight javascript"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">CoolModule</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="keyword">var</span> something = <span class="string">'cool'</span>;</div><div class="line">  <span class="keyword">var</span> another = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  	<span class="built_in">console</span>.log(something);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">doAnother</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  	<span class="built_in">console</span>.log(another.join(<span class="string">'!'</span>));</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">      <span class="attr">doSomething</span>: doSomething,</div><div class="line">      <span class="attr">doAnother</span>: doAnother</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> foo = CoolModule();</div><div class="line">foo.doSomething();<span class="comment">//cool</span></div><div class="line">foo.doAnother();<span class="comment">//1!2!3</span></div></pre></td></tr></table></figure>
<p>这个模式在Js中被称作模块，这个对象类型的返回值最终被赋值给外部的变量foo，然后就可以通过它来访问模块的公共属性方法。<br>doSomething()和doAnother()函数具有涵盖模块实例内部作用域的闭包。这样就可以访问coolModule()作用域内的属性方法。</p>
<h1 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h1><p>当函数可以<code>记住并访问所在的词法作用域</code>时，就产生了闭包，即使函数实在<code>当前词法作用域之外</code>执行。</p>
<p><strong>闭包的两个主要特征：</strong></p>
<ul>
<li>为创建内部作用域而调用了一个包装函数</li>
<li>包装函数的返回值必须至少包括一个对内部函数的引用，这样会创建涵盖整个包装函数内部作用域的闭包。</li>
</ul>
]]></content>
      
        
        <tags>
            
            <tag> 技术 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Hello Fucking World]]></title>
      <url>http://valar.me/2017/02/16/hello-world/</url>
      <content type="html"><![CDATA[<p>Welcome to <a href="https://hexo.io/" target="_blank" rel="external">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/" target="_blank" rel="external">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html" target="_blank" rel="external">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues" target="_blank" rel="external">GitHub</a>.</p>
<h2 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h2><h3 id="Create-a-new-post"><a href="#Create-a-new-post" class="headerlink" title="Create a new post"></a>Create a new post</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo new <span class="string">"My New Post"</span></div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/writing.html" target="_blank" rel="external">Writing</a></p>
<h3 id="Run-server"><a href="#Run-server" class="headerlink" title="Run server"></a>Run server</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo server</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/server.html" target="_blank" rel="external">Server</a></p>
<h3 id="Generate-static-files"><a href="#Generate-static-files" class="headerlink" title="Generate static files"></a>Generate static files</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo generate</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/generating.html" target="_blank" rel="external">Generating</a></p>
<h3 id="Deploy-to-remote-sites"><a href="#Deploy-to-remote-sites" class="headerlink" title="Deploy to remote sites"></a>Deploy to remote sites</h3><figure class="highlight bash"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">$ hexo deploy</div></pre></td></tr></table></figure>
<p>More info: <a href="https://hexo.io/docs/deployment.html" target="_blank" rel="external">Deployment</a></p>
]]></content>
      
        
        <tags>
            
            <tag> 杂 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
