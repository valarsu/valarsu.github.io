<!DOCTYPE html><html lang="zh-CN"><head><meta charset="utf-8"><meta name="X-UA-Compatible" content="IE=edge"><meta name="author" content="七娃,valar_su@163.com"><title>HTTP笔记 · 七娃</title><meta name="description" content="HTTP对我来说一直是弱项，所以最近看了很多相关资料，记录笔记如下，意在深入理解HTTP。

HTTP简介
HTTP协议是互联网上应用最为广泛的一种网络协议，也是浏览器和服务器通信时所采用的协议。在展示网页时，浏览器向服务器发起一个HTTP请求，以获取相应的网站数据，然后在客户端展示相应的内容。
与"><meta name="keywords" content="Hexo,HTML,Ben,CSS,安卓,android,Linux,linuxdeepin"><meta content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=0" name="viewport"><meta content="yes" name="apple-mobile-web-app-capable"><meta content="black" name="apple-mobile-web-app-status-bar-style"><meta content="telephone=no" name="format-detection"><meta name="renderer" content="webkit"><link rel="short icon" href="/images/favicon.png" type="image/x-icon"><link rel="stylesheet" href="/css/style.css"><link rel="stylesheet" href="/css/blog_basic.css"><link rel="stylesheet" href="/css/font-awesome.min.css"><link rel="alternate" type="application/atom+xml" title="ATOM 1.0" href="/atom.xml"></head><body><div class="sidebar animated fadeInDown"><div class="logo-title"><div class="title"><img src="/images/logo@2x.png" style="width:127px;"><h3 title=""><a href="/">七娃</a></h3><div class="description"><p>江湖夜雨十年灯，人生何处不相逢。</p></div></div></div><ul class="social-links"><li><a href="http://instagram.com/valarsu"><i class="fa fa-instagram"></i></a></li><li><a href="http://weibo.com//u/3525084425"><i class="fa fa-weibo"></i></a></li><li><a href="https://github.com/valarsu"><i class="fa fa-github"></i></a></li></ul><div class="footer"><a target="_blank" href="/"><span>Theme by </span></a><a href="https://www.caicai.me"> CaiCai</a><span>&</span><a href="https://github.com/Ben02/hexo-theme-Anatole"> Ben</a><div class="by_farbox"><a href="https://hexo.io/zh-cn/" target="_blank">Proudly published with Hexo&#65281;</a></div></div></div><div class="main"><div class="page-top animated fadeInDown"><div class="nav"><li><a href="/">首页</a></li><li><a href="/about">关于</a></li><li><a href="/archives">归档</a></li><li><a href="/links">友链</a></li></div><div class="information"><div class="back_btn"><li><a onclick="window.history.go(-1)" class="fa fa-chevron-left"> </a></li></div><div class="avatar"><img src="http://olh78p45s.bkt.clouddn.com/head.jpeg"></div></div></div><div class="autopagerize_page_element"><div class="content"><div class="post-page"><div class="post animated fadeInDown"><div class="post-title"><h3><a>HTTP笔记</a></h3></div><div class="post-content"><blockquote>
<p>HTTP对我来说一直是弱项，所以最近看了很多相关资料，记录笔记如下，意在深入理解HTTP。</p>
</blockquote>
<h1 id="HTTP简介"><a href="#HTTP简介" class="headerlink" title="HTTP简介"></a>HTTP简介</h1><blockquote>
<p>HTTP协议是互联网上应用最为广泛的一种网络协议，也是浏览器和服务器通信时所采用的协议。在展示网页时，浏览器向服务器发起一个HTTP请求，以获取相应的网站数据，然后在客户端展示相应的内容。</p>
<p>与HTTP协议紧密相关的还有HTTPS协议，它通过SSL和HTTP协议构建可进行加密传输、身份认证的网络协议，能防止数据在传输过程中被挟持或篡改，可以看作是HTTP协议的安全版。</p>
<p>HTTP是Web开发中必须掌握的技术，除了协议本身外，缓存机制、表单的method方法，跨域、网络安全等，都是在页面开发过程中涉及的网络相关的技术点。</p>
</blockquote>
<a id="more"></a>
<h1 id="TCP-IP协议族"><a href="#TCP-IP协议族" class="headerlink" title="TCP/IP协议族"></a>TCP/IP协议族</h1><blockquote>
<p>TCP/IP协议族是网络通信需要的各种协议的统称。如从电缆的规格到IP地址的选当方法、寻找异地用户的方法、双方建立通信的顺序、Web页面显示需要处理的步骤等等。</p>
</blockquote>
<h2 id="分层管理"><a href="#分层管理" class="headerlink" title="分层管理"></a>分层管理</h2><ol>
<li>应用层：决定向用户提供应用服务时通信的活动。比如FTP（文件传输协议）和DNS（域名系统）服务就是其中的两类应用。</li>
<li>传输层：对应用层提供处于网络连接中的两台计算机之间的数据传输。传输层中有两个性质不同的协议，TCP（传输控制协议）和UDP（用户数据报协议）</li>
<li>网络层（网络互联层）：处理在网络上流动的数据包（网络传输的最小数据单位）。规定了通过怎样的传输路线到达对方计算机，并把数据包传送给对方。</li>
<li>数据链路层（网络接口层）：用来处理连接网络的硬件部分。包括控制操作系统、硬件的设备驱动、NIC（网卡）、光纤等物理可见部分。</li>
</ol>
<h2 id="TCP-IP通信传输流"><a href="#TCP-IP通信传输流" class="headerlink" title="TCP/IP通信传输流"></a>TCP/IP通信传输流</h2><blockquote>
<p>应用层（HTTP协议）发送一个请求 <code>-&gt;</code> 传输层（TCP协议）把收到的数据（HTTP请求报文）进行分割，并在各报文上打标记序号及端口号 <code>-&gt;</code> 网络层（IP协议）增加作为通信目的地的MAC地址 <code>-&gt;</code> 链路层（网络） <code>-&gt;</code> 接收端以相反的方向进行。</p>
</blockquote>
<h2 id="IP、TCP和DNS"><a href="#IP、TCP和DNS" class="headerlink" title="IP、TCP和DNS"></a>IP、TCP和DNS</h2><ul>
<li>IP：网络协议（不要把IP和IP地址搞混），位于网络层，作用是要把正确的数据包传送给对方，所以要满足各种条件，最重要的是IP地址（节点被分配到的地址）和MAC地址（网卡所属的固定地址）。网络传输时，要经过多台设备进行中转，中转过程中会用ARP协议根据IP地址解析出中专目标的MAC地址。</li>
<li>TCP：位于传输层，提供可靠的字节流服务。为了传送大数据而把数据分割成以报文段为单位的数据包进行传输，并且能确定数据最终是否能到达。<ul>
<li>三次握手：为了确保能把数据送到目的地，TCP使用flag：<code>SYN</code>和<code>ACK</code>进行三次握手。发送端先发送一个带SYN的数据包给对方，对方接收到后，会回发一个带有SYN/ACK的数据包表示接收到了，然后发送端再发送一个带ACK的数据包，代表握手结束。</li>
</ul>
</li>
<li>DNS：和HTTP一样在应用层，负责域名解析。因为计算机识别IP地址比识别域名要容易，所以用DNS来将域名解析成IP地址，以供服务器识别。也可以通过IP反查域名。</li>
</ul>
<h2 id="URI和URL"><a href="#URI和URL" class="headerlink" title="URI和URL"></a>URI和URL</h2><ul>
<li>URI：统一资源标识符，用字符串标识某个协议方案（HTTP、FTP、file等）标识的互联网资源</li>
<li>URL：统一资源定位符，表示资源的地点（所以URL是URI的子集）</li>
</ul>
<h3 id="URI的格式"><a href="#URI的格式" class="headerlink" title="URI的格式"></a>URI的格式</h3><p><img src="http://olh78p45s.bkt.clouddn.com/image/http/WechatIMG21.jpeg" alt="URI的格式"></p>
<h1 id="HTTP协议"><a href="#HTTP协议" class="headerlink" title="HTTP协议"></a>HTTP协议</h1><h2 id="基本规则"><a href="#基本规则" class="headerlink" title="基本规则"></a>基本规则</h2><ul>
<li>应用HTTP协议时，必定有一个客户端，一个服务器端。</li>
<li>请求必定由客户端发出，收到请求后，服务器端响应该请求并返回。</li>
<li>请求报文由请求方法、请求URI、协议版本、可选的请求首部字段和内容实体构成。</li>
<li>响应报文由协议版本、状态码、用以解释状态码的原因短语、可选的响应首部字段以及实体主体构成。</li>
<li>HTTP时无状态的协议，不保存状态。类似于金鱼的七秒钟记忆v_v,一次通信请求成功之后不会记录上一次的请求内容。</li>
</ul>
<h2 id="告知服务器意图的HTTP方法"><a href="#告知服务器意图的HTTP方法" class="headerlink" title="告知服务器意图的HTTP方法"></a>告知服务器意图的HTTP方法</h2><ul>
<li>GET：获取资源，返回通信状态及实体</li>
<li>POST：传输实体主体</li>
<li>PUT：发送文件</li>
<li>HEAD：和GET方法一样，但是只返回通信状态</li>
<li>DELETE：删除文件，与PUT的方法相反</li>
<li>OPTIONS：用来查询针对请求URI指定的资源支持的方法，响应报文会有一个Allow字段返回方法，<code>Allow: GET, POST, HEAD, OPTIONS</code></li>
<li>TRACE：让服务器端将之前的请求通信路径返回给客户端（不常用）</li>
<li>CONNECT：要求与代理服务器通信时建立隧道，实现用隧道协议进行TCP通信。</li>
</ul>
<h2 id="建立持久连接"><a href="#建立持久连接" class="headerlink" title="建立持久连接"></a>建立持久连接</h2><p>初始版本中每进行一次HTTP通信就要断开一次TCP连接，每次都要三次握手四次挥手啥的，累死了。</p>
<p>后来出现了持久连接<code>HTTP keep-alive</code>，只要任意一端没有明确提出断开连接，就保持TCP连接状态。</p>
<h3 id="管线化"><a href="#管线化" class="headerlink" title="管线化"></a>管线化</h3><p>初始版本中发送请求后必须等待收到响应后才能发送下一个请求，管线化就是发送请求后不需要等待响应，就可以继续发送下一个请求。相当于每次请求之间实现了多线程异步处理。</p>
<h2 id="使用Cookie的状态管理"><a href="#使用Cookie的状态管理" class="headerlink" title="使用Cookie的状态管理"></a>使用Cookie的状态管理</h2><p>由于HTTP是无状态的协议，那么需要记住状态的请求就需要用别的方法来实现，所以引入了cookie。</p>
<p>cookie会根据从服务器端发送的响应豹纹内的首部字段信息，通知客户端保存Cookie，当下次客户端再往该服务器发送请求时，客户端会自动在请求报文中加入Cookie值后发出去。</p>
<p>服务器端发现客户端发过来的cookie后，会去检查究竟是哪一个客户端发过来的连接请求，然后对比服务器上的记录，最后得到之前的状态信息。</p>
<h1 id="HTTP报文内的HTTP信息"><a href="#HTTP报文内的HTTP信息" class="headerlink" title="HTTP报文内的HTTP信息"></a>HTTP报文内的HTTP信息</h1><p>用于HTTP协议交互的信息被称为HTTP报文，客户端的HTTP报文叫做请求报文，服务器端的叫做响应报文。</p>
<p>HTTP报文大致可氛围报文首部和报文主体两块，两者由最初出现的空行（CR+LF）来划分，通常报文主体不是必须的。</p>
<ul>
<li>报文首部：服务器端或者客户端处理的请求或响应的内容及属性</li>
<li>报文主体：应被发送的数据</li>
<li>报文首部结构<ul>
<li>请求报文：请求行、请求首部字段、通用首部字段、实体首部字段、其他</li>
<li>响应报文：状态行、相应首部字段、通用首部字段、实体首部字段、其他<ul>
<li>请求行：包含用于请求的方法，请求URI和HTTP版本</li>
<li>状态航：包含表明响应结果的状态码，原因短语和HTTP版本</li>
<li>首部字段：包含表示请求和响应的各种条件和属性的各类首部</li>
<li>其他：可能包含HTTP的RFC里未定义的首部（Cookie等）</li>
</ul>
</li>
</ul>
</li>
</ul>
<h2 id="编码提升传输速率"><a href="#编码提升传输速率" class="headerlink" title="编码提升传输速率"></a>编码提升传输速率</h2><p>HTTP在传输数据时可以按照数据原貌直接传输，但是在处理大量访问请求时可以通过编码传输，但是编码要计算机完成，因此会消耗CPU资源</p>
<h3 id="报文主体和实体主体的差异"><a href="#报文主体和实体主体的差异" class="headerlink" title="报文主体和实体主体的差异"></a>报文主体和实体主体的差异</h3><ul>
<li>报文：是HTTP通信的基本单位，由8个字节流组成，通过HTTP通信传输</li>
<li>实体：作为请求或相应的有效载荷数据（补充项）被传输，其内容由实体首部和实体主体组成</li>
<li>HTTP报文的主体用来传输请求或响应的实体主体</li>
<li>通常报文主体等于实体主体，只有在传输中进行编码操作时实体主体的内容发生变化，才导致它和它的报文主体产生差异</li>
</ul>
<h3 id="编码种类"><a href="#编码种类" class="headerlink" title="编码种类"></a>编码种类</h3><ul>
<li>内容编码：指明应用在实体内容上的编码格式，并保持实体信息原样压缩，内容编码后的实体由客户端接收并非责编码。</li>
<li>分块传输编码：HTTP通信过程中，请求的编码实体资源没传完之前浏览器没办法显示请求页面，所以在传输大容量数据时，把数据分割成多块，能让浏览器逐步显示页面。由接收的客户端来解码。</li>
<li>多部分对象集合：发送一份报文主体可以含有多类型实体，通常是在图片或文本文件等上传时使用<ul>
<li><code>Content-Type: multipart/form-data</code>：在Web表单文件上传时使用</li>
<li><code>Content-Type: multipart/byteranges</code>：状态码206（部分内容）响应报文包含了多个范围的内容时使用</li>
</ul>
</li>
<li>使用boundary字符串来划分多部分对象集合指明的各类实体</li>
</ul>
<h2 id="获取部分内容的范围请求"><a href="#获取部分内容的范围请求" class="headerlink" title="获取部分内容的范围请求"></a>获取部分内容的范围请求</h2><ul>
<li>下载过程中如果遇到网络中断，就必须从头开始，为了解决这个问题，需要一种可恢复的机制，使其能从之前下载中断处回复下载，也就是我们常说的断点续传。这种指定范围发送的请求叫做范围请求</li>
<li>执行范围请求时，会用到首部字段Range来制定资源的byte范围 <code>Range: bytes=5001-10000</code> 或 <code>Range: bytes=5001-</code> <code>Range: bytes=-3000，5001-10000</code> 多种写法。</li>
<li>范围请求时，响应会反悔状态码206，响应也会在首部字段<code>Content-Type</code>标明<code>multipart/byteranges</code>后返回响应报文。</li>
<li>如果服务器无法响应范围请求，则会返回状态码200 OK和完整的实体内容</li>
</ul>
<h2 id="内容协商"><a href="#内容协商" class="headerlink" title="内容协商"></a>内容协商</h2><ul>
<li>内容协商是指客户端和服务器端就响应的资源内容进行交涉，然后提供给客户端最为合适的资源。一般以响应资源的语言、字符集、编码方式等作为判断的基准。比如访问www.google.com，浏览器默认是英文就反回英文版页面，是中文就返回中文版页面</li>
<li>包含在请求报文的某些首部字段就是判断的基准，比如：Accept、Accept-Charset、Accept-Encoding、Accept-Language、Content-Language</li>
<li>三种类型<ul>
<li>服务器驱动协商：服务器端根据请求的首部字段作为参考，在服务器端自动处理</li>
<li>客户端驱动协商：用户通过设置浏览器、js脚本等方式，比如切换浏览器类型、PC版页面活着手机版页面等</li>
<li>透明协商：服务器端和客户端各自进行内容协商。</li>
</ul>
</li>
</ul>
<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><h2 id="每类状态码的含义"><a href="#每类状态码的含义" class="headerlink" title="每类状态码的含义"></a>每类状态码的含义</h2><ul>
<li>1xx（临时响应）：表示临时响应并需要请求者继续执行操作</li>
<li>2xx（成功）：表示成功处理了请求</li>
<li>3xx（重定向）：表示要完成请求需要进一步操作，通常这些状态码用来重定向</li>
<li>4xx（错误）：表示请求可能出错，妨碍了服务器的处理，（客户端错误）</li>
<li>5xx（服务器错误）：表示服务器在尝试处理请求时发生内部错误，（服务器端错误）</li>
</ul>
<h2 id="14种常用状态码："><a href="#14种常用状态码：" class="headerlink" title="14种常用状态码："></a>14种常用状态码：</h2><ul>
<li>200（成功）：服务器已经成功处理了请求。通常这表示服务器提供了请求的页面</li>
<li>204（成功，但是没有资源返回）：请求已经成功处理，但是响应报文中不含实体的主体部分，也不允许返回任何实体的主体</li>
<li>206（范围请求）：客户端发起范围请求，服务器成功执行，响应报文中包含由Content-Range指定范围内的实体内容</li>
<li>301（永久性重定向）：服务器告知资源的URI已经更新，以后应使用资源现在所指的URI</li>
<li>302（临时重定向）：表示请求的资源被分配了新的URI，希望用户（本次）能使用新的URI访问</li>
<li>303（发现其他URI）：请求的资源存在另一个URI，应使用GET方法定向获取请求的资源，明确使用GET方法</li>
<li>304（未修改）：客户端发送附带条件的请求时，服务器端允许请求访问资源，但是未满足条件的情况，返回时不包含任何响应的主体部分</li>
<li>307（临时重定向）：和302有相同的含义</li>
<li>400（语法错误）：请求报文中存在语法错误，需要修改请求内容后再次发送请求</li>
<li>401（未授权）：请求要求身份验证。对于需要登录的网页，服务器可能返回此响应</li>
<li>403（禁止）：服务器拒绝请求，比如未获得资源的访问授权、访问权限出现某些问题等情况</li>
<li>404（未找到）：服务器找不到请求的资源</li>
<li>500（服务器故障）：服务器端在执行请求时发生了错误，也有可能是web应用存在bug或某些临时的故障</li>
<li>503（服务器繁忙）：服务器暂时出去超负载或正在进行停机维护，现在无法处理请求。</li>
</ul>
<h1 id="服务器相关"><a href="#服务器相关" class="headerlink" title="服务器相关"></a>服务器相关</h1><p>一台web服务器既可以搭建网站，又可以作为佟鑫路径上的中转服务器提升传输效率。</p>
<h2 id="用单台虚拟主机实现多个域名"><a href="#用单台虚拟主机实现多个域名" class="headerlink" title="用单台虚拟主机实现多个域名"></a>用单台虚拟主机实现多个域名</h2><p>客户端使用HTTP协议访问服务器时，使用普通域名，然后DNS服务器解析成IP地址之后访问目标网站。</p>
<p>如果一台HTTP服务器通过虚拟机功能搭建多个Web站点，那么多个域名就会解析到同一个ip地址，那么问题来了，服务器怎么区分不同的域名访问的呢？<br>因为相同ip下，虚拟主机可以寄存多个主机和域名的网站，所以请求时，必须host首部内完整指定主机名或域名的URI。</p>
<h2 id="通信数据的转发程序：代理、网关、隧道"><a href="#通信数据的转发程序：代理、网关、隧道" class="headerlink" title="通信数据的转发程序：代理、网关、隧道"></a>通信数据的转发程序：代理、网关、隧道</h2><p>以上三个是用于在HTTP通信中，介于客户端和服务器端之间的用来进行数据转发的应用程序。</p>
<ul>
<li>代理：介于客户端和服务器端之间，起过渡作用。可以将请求转发给下一个服务器，并能接收那台服务器发送的响应并回传给客户端。不改变请求URI，每次使用代理服务器转发请求或者响应时，会追加Via首部信息<code>Via: proxy1， proxy2</code>，可以多台服务器同时代理，像电路的串联一样进行来回通信。<ul>
<li>应用场景：利用缓存技术减少网络带宽的流量、组织内部针对特定网站的访问限制等  </li>
<li>缓存代理：转发响应时，缓存代理会预先将资源的缓存保存在代理服务器上。这样再次接到相同的请求时，就可以将代理服务器上缓存的资源返回</li>
<li>透明代理：转发请求或响应时，不对报文做任何加工，反之则是非透明代理</li>
</ul>
</li>
<li>网关：是转发其他服务器上的数据的服务器。<ul>
<li>和代理非常相似，但是网关可以将HTTP转换为其他协议进行通信。</li>
<li>网关可以提升通信的安全性，因为可以在客户端与网关的线路上加密。比如网关可以连接数据库，或者网购使用信用卡结算时，可以和信用卡结算系统联动。</li>
</ul>
</li>
<li>隧道：在距离超级长的客户端与服务器端之间进行中转，保持双方通信安全连接。<ul>
<li>可以按要求建立起一条连接其他服务器的线路，通过SSL进行加密，目的是确保客户端和服务器端的通信安全</li>
<li>隧道是透明的，不对请求做任何修改，直接传给其他服务器，所以客户端不用在意隧道的存在，通信双方断开连接时，隧道自动断开</li>
</ul>
</li>
</ul>
<h2 id="保存资源的缓存"><a href="#保存资源的缓存" class="headerlink" title="保存资源的缓存"></a>保存资源的缓存</h2><ul>
<li>缓存是指代理服务器或客户端磁盘内保存的资源副本，可以减少对源服务器的访问，节省流量和时间</li>
<li>缓存服务器是代理服务器的一种，当缓存代理转发响应时，会保存一份资源的副本</li>
<li>有效性：当源服务器上的资源更新时，如果使用不变的缓存，那么缓存就会变成旧的资源，所以每次使用缓存时，都会向源服务器确认缓存的有效性，如果失效，就会从源服务器上重新获取新的资源</li>
<li>客户端缓存：本地磁盘也可以存储缓存，如果有效，就可以直接从磁盘获取资源，不用再向服务器请求。客户端缓存也有生命周期，和缓存服务器一样，向源服务器确认缓存的有效性</li>
</ul>
<h1 id="经典问题"><a href="#经典问题" class="headerlink" title="经典问题"></a>经典问题</h1><h2 id="问题1"><a href="#问题1" class="headerlink" title="问题1"></a>问题1</h2><p>HTTP协议是无状态的，为了保持用户会话状态使用了什么技术方案弥补？该技术方赞在用户禁用了cookie之后，还有什么方式实现（可不考虑安全性）？</p>
<h3 id="解析"><a href="#解析" class="headerlink" title="解析"></a>解析</h3><p>我们常用的保存会话状态的方式有cookie、session、URL GET参数：</p>
<ol>
<li>cookie是保存在浏览器终端内存或者磁盘上的一小块数据，只能保存字符串类型，所有的cookie信息都会随着浏览器的请求而发送。cookie分为：会话cookie：数据保存在内存中，浏览器关闭后将被清除；持久cookie：数据保存在磁盘中。尽管几乎所有浏览器都支持cookie，但是浏览器对单域下cookie的个数和每个key的长度都有限制。</li>
<li>session是一种服务器端的机制，服务器使用一种类似于散列表的结构来保存信息，客户端需要接收、记忆和回送session的会话标识号，session通常是借助客户端存储的cookie来记录会话标识。</li>
<li>GET参数是URL中的普通参数，GET方式是明文传输，其传送的数据量一般会有限制，美中浏览器支持的最大长度会略有不同。</li>
</ol>
<p>要实现保持用户状态，服务端在客户端第一次访问时会自动创建一个session来存储客户端的信息，同时生成一个唯一的key发送给客户端。</p>
<ol>
<li>客户端没有禁用cookie：服务器会在客户端cookie中写入一个key的值，用户保存用户信息，之后的每一次访问都会携带cookie给服务端，服务器可以根据这个值判断用户的唯一性</li>
<li>客户端禁用了cookie：需要将验证信息写入URL中，所有的请求也需要携带这个参数，比如说<code>www.tfdd.com?session_id=xxxxx</code>，相对于cookie来说要麻烦一点，因为页面上所有的链接和请求都必须携带该参数，否则客户端会丢失会话状态</li>
</ol>
<h2 id="问题2"><a href="#问题2" class="headerlink" title="问题2"></a>问题2</h2><p>URL输入浏览器到页面呈现，这中间发生了什么？</p>
<h2 id="解析-1"><a href="#解析-1" class="headerlink" title="解析"></a>解析</h2><ol>
<li>URL输入到浏览器，负责域名解析的DNS服务会通过域名查找对应的IP地址（也就是获得URL对应的IP地址）；</li>
<li>利用TCP/IP协议族进行网络通信，发送数据包，建立网络连接。客户端会向服务端发送请求，服务端会响应客户端的请求。其中，客户端想浏览器发送请求，发送会经历应用层（HTTP报文）-&gt;传输层（增加TCP头部）-&gt;网络层（IP数据包，增加IP头部）-&gt;数据链路层（增加以太网头部）；服务端则相反。</li>
<li>客户端渲染，渲染引擎对html进行转换，转化成能够被DOM处理的形式，接着转换成一个DOM树，在解析HTML的过程，会发送请求把对应的内容货渠道，同时进行css的解析，构建出css样式规则应用到DOM树上，然后进行一定的布局处理，最后根据这棵渲染树在浏览器窗口进行绘制。</li>
</ol>
</div><div class="post-footer"><div class="meta"><div class="info"><i class="fa fa-sun-o"></i><span class="date">2017-02-20</span><i class="fa fa-comment-o"></i><a href="/2017/02/20/about-http/#comments">评论</a><i class="fa fa-tag"></i><a href="/tags/技术/" title="技术" class="tag">技术 </a></div></div></div></div><div class="share"><div class="evernote"> <a href="javascript:(function(){EN_CLIP_HOST='http://www.evernote.com';try{var%20x=document.createElement('SCRIPT');x.type='text/javascript';x.src=EN_CLIP_HOST+'/public/bookmarkClipper.js?'+(new%20Date().getTime()/100000);document.getElementsByTagName('head')[0].appendChild(x);}catch(e){location.href=EN_CLIP_HOST+'/clip.action?url='+encodeURIComponent(location.href)+'&amp;title='+encodeURIComponent(document.title);}})();" ref="nofollow" target="_blank" class="fa fa-bookmark"></a></div><div class="weibo"> <a href="javascript:void((function(s,d,e){try{}catch(e){}var f='http://service.weibo.com/share/share.php?',u=d.location.href,p=['url=',e(u),'&amp;title=',e(d.title),'&amp;appkey=2924220432'].join('');function a(){if(!window.open([f,p].join(''),'mb',['toolbar=0,status=0,resizable=1,width=620,height=450,left=',(s.width-620)/2,',top=',(s.height-450)/2].join('')))u.href=[f,p].join('');};if(/Firefox/.test(navigator.userAgent)){setTimeout(a,0)}else{a()}})(screen,document,encodeURIComponent));" class="fa fa-weibo"></a></div><div class="twitter"> <a href="http://twitter.com/home?status=,http://valar.me/2017/02/20/about-http/,七娃,HTTP笔记,;" class="fa fa-twitter"></a></div></div><div class="pagination"><ul class="clearfix"><li class="pre pagbuttons"><a role="navigation" href="/2017/02/22/jshint/" title="gulp构建时，安装jshint报错的解决方法" class="btn">上一篇</a></li><li class="next pagbuttons"><a role="navigation" href="/2017/02/16/closure/" title="我理解的闭包" class="btn">下一篇</a></li></ul></div><a id="comments"></a><div data-thread-key="2017/02/20/about-http/" data-title="HTTP笔记" data-url="http://valar.me/2017/02/20/about-http/" data-author-key="1" class="ds-thread"></div><script>var duoshuoQuery = {short_name:"苏浩-七娃"};
(function() {
    var ds = document.createElement('script');
    ds.type = 'text/javascript';ds.async = true;
    ds.src = (document.location.protocol == 'https:' ? 'https:' : 'http:') + '//static.duoshuo.com/embed.js';
    ds.charset = 'UTF-8';
    (document.getElementsByTagName('head')[0] 
     || document.getElementsByTagName('body')[0]).appendChild(ds);
})();

</script></div></div></div></div><script src="/js/jquery.js"></script><script src="/js/jquery-migrate-1.2.1.min.js"></script><script src="/js/jquery.appear.js"></script></body></html>